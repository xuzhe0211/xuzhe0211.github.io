---
autoGroup-16: Tips/方法实现
title: 判断一个节点是否包含另一个节点
---
大家平时在开发的时候有没被new Date()折磨过？就是它的诸多怪异的设定让每每用的时候，都可能不小心踩坑。造成程序意外出错，却一下子找不到问题出处，那叫一个烦透了.....下面，我就列举它的『四宗罪』及引用思考

## 可恶的四宗罪
1. Safari浏览器不兼容YYYY-MM-DD这样的格式

    ```js
    new Date('2023-1-1')
    ```
    这行代码无论在Macbook中还是在iphone中的Safari浏览器，返回的都是Invalid Date，Safari浏览器目前还理解不了YYYY-MM-DD这样的格式，只支持YYYY/MM/DD。这就造成你在Windows环境下的嗲吗正常原型，而你的其他部分用户异常显示；
2. 月份的索引是以0为起点的，而年份、日期却不是

    ```js
    new Date(2023,1,1)
    ```
    得到的是一个反直觉的结果：2023年2月1日！！！
    ```js
    Wed Feb 01 2023 00:00:00 GMT+0800 (中国标准时间)
    ```
    同样的，对应的方法.setMonth()也是从0开始设置的。就....很无语
3. 年份小于100，默认以19xx或20xx开头

    一般的应用可能碰不到这样的情况，毕竟现在是21世纪了，我们在应用中看到的大部分时间都是现代的。但是当你需要格式化公元元年-公元100年之间的时间，你就该蒙了

    举个栗子
    ```js
    new Date(2023,1,1)
    ```
    能正常返回时间对象
    ```js
    Wed Feb 01 2023 00:00:00 GMT+0800 (中国标准时间)
    ```
    但是当年份调到东汉时间，公元50年2月1日
    ```js
    new Date(50,2,1)
    ```
    恭喜你，你直接迎接了新中国！见证了历史：
    ```js
    Wed Mar 01 1950 00:00:00 GMT+0800 (中国标准时间)
    ```
    是的，Date直接帮你加了1900年的时间！**如果需要获得公元50年2月1日，得这么写**
    ```js
    new Date('0050-02-01');
    ```
    返回
    ```js
    Tue Feb 01 0050 08:05:43 GMT+0805 (中国标准时间)
    ```
    请千万不要尝试添加时间，因为你又要裂开了……
    ```js
    new Date('0050-02-01 00:00:00');
    ```
    返回
    ```js
    Wed Feb 01 1950 00:00:00 GMT+0800 (中国标准时间)
    ```
    你就说，它任性吧？！别气馁，别忘了标题还有20xx的情况
    ```js
    new Date('10-11-12');
    ```
    返回
    ```js
    Thu Oct 11 2012 00:00:00 GMT+0800 (中国标准时间)
    ```
    就是说，当年份为2位数的时候，这种字符串格式的，构造函数把最后面那个当作年份，而且默认它为20xx年

4. 日期初始化不统一，存在市区差异

    你相信吗？'2018-01-01'和'2018/01/01'是不同的，存在一定时差
    ```js
    new Date('2018-01-01')
    ```
    返回
    ```js
    Mon Jan 01 2018 08:00:00 GMT+0800 (中国标准时间)
    ```
    然而……
    ```js
    new Date('2018/01/01');
    ```
    返回
    ```js
    Mon Jan 01 2018 00:00:00 GMT+0800 (中国标准时间)
    ```
    看到差异了吗？两种格式返回的时间是不同的，查了个北京时间与格林尼治时间的时差，8个小时啊！
## 应用思考
在日常开发中，我们应用 new Date()无非就是对时间运算及时间的格式化
1. 时间的计算

    需要方便对比两个时间的早晚，可以分别对年份、月份、日期、小时等进行单独比较。而我们现有的操作还比较麻烦

    比如，我想知道2003年7月13日北京申奥成功到2008年8月8日北京奥运开幕中间差了几天，如何快速计算？这样的计算在日常开发中还比较常见，特别是电商网站对抢购环节的倒计时。

    还有诸如，当前时间在100天以后又是几月几号呢？

2. 时间的比较

    给定两个时间，判断哪个在前，哪个在后；给定一个时间返回，判断某个时间是不是在这两者之间

3. 时间的格式化

    在网站开发中，我们最常见的就是对后台返回时间戳的格式化显示。而原生带来的仅有年份如何获取，月份如何获取，日期如何获取的方法，就方便的无非就是toISOString()这样的方法，但是返回的却不一定是你要的格式。如何快速实现自定义格式化字符串，这也是一门技术。

## 困境的解决
想必大家日常中也用过 moment.js、dayjs、data-format这些工具吧？确实挺好用的，我也就顺便说一下而已。因为我要开始打广告了……面对着new Date()各种无语的坑，我慢慢的也弄了一个不大的库(250行左右代码)。

你要说我的库和前面的几个库对比，有啥改进的或者有啥特点的吗？

😂确实也没有，我只是想用自己造的“轮子”，走自己路。它更符合我自己的使用习惯罢了

【项目开源地址】https://github.com/mumuy/datex

【项目演示地址】https://passer-by.com/datex/

提供的方法足以解决以上“四宗罪”及日常应用。它提供多种初始化时间的方式：

- 实例化对象

    ```js
    // 通过时间戳
    datex(123456789);

    // 通过多个参数初始化
    datex(2018,8,8);

    // 通过时间字符串初始化
    datex('2018-08-08');
    datex('2018-04-04T16:00:00.000Z');

    // 通过时间对象初始化
    datex({year:2008,month:8,day:8,hour:8,minute:0,second:0});

    // 通过时间数组初始化
    datex([2018,8,8,8,8,0]);

    // 无参数初始化
    datex();
    ```
- 时间戳及克隆

    ```js
    // 返回时间戳(毫秒)
    datex().getTime();

    // 返回时间戳(秒)
    datex().getUnix();

    // 克隆
    datex().clone();
    ```
- 时间对象输出

    ```js
    // 返回原生Date对象
    datex().toDate();

    // 返回时间字段对象
    datex().toObject();

    // 返回时间字段数组
    datex().toArray();

    // 返回字符串
    datex().toString();

    // 返回ISO字符串
    datex().toISOString();

    ```
- 时间格式化

    ```js
    datex(123456789).format('YYYY-MM-DD');
    ```
- 时间计算及比较

    ```js
    // 设置某字段值
    datex(2022,10,1).set('year',2020).format();

    // 增减某字段值，负值为减
    datex(2022,10,1).change('year',1).format();

    // 返回某字段值
    datex().get('month');

    // 获取某字段起始时
    // 例如：获取这个月初是星期几？
    datex().startOf('month').format('W');

    // 获取某字段末尾时
    // 例如：获取这个月有多少天？(是不是很容易理解？end of month then get day!)
    datex().endOf('month').get('day');

    // 与某时间点差值
    // 例如：北京2008年奥运会开幕式过去多少天了？
    datex().diffWith('2008-8-8','day');

    // 是否在某个时间点之前
    datex('2008-08-08').isBefore('2022-02-02');

    // 是否在某个时间点之后
    datex('2008-08-08').isAfter('2022-02-02');

    // 是否和某个时间点相等
    datex('2008-08-08').isSame('2018-02-02','year');

    // 是否在两个时间点之间
    datex('2008-08-08').isBetween('2003-07-13','2022-02-02');

    ```
- 有效性

    ```js
    datex('2008-13-12').isValid();
    ```

## 资料
[判断一个节点是否包含另一个节点](https://mp.weixin.qq.com/s/EctWBjmL_w32UWV_DW66NA)