(window.webpackJsonp=window.webpackJsonp||[]).push([[805],{2939:function(t,e,a){"use strict";a.r(e);var s=a(46),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("举个例子")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 筛选 docker帮助中 包含dns的\ndocker run --help | grep dns\n")])])]),a("h2",{attrs:{id:"基本语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),a("p",[t._v("grep这个linux指令大家一定不陌生，其用于查找文件中符合条件的字符串，下面来看这个高频的指令如何使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("grep [选项] 查找内容 [源文件]\n")])])]),a("p",[t._v("观察其组成部分，由四部分组成:指令明(grep)、选项、查找内容、源文件，其中需要注意的有两个位置，下来我们一一道来")]),t._v(" "),a("h3",{attrs:{id:"_1-源文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-源文件"}},[t._v("#")]),t._v(" 1. 源文件")]),t._v(" "),a("p",[t._v("源文件部分是可有可无的，若不指定任何文件名称或是所给予的文件名为-,则grep指令会从标准输入设备读取数据，使用如下所示")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 文件路径为/test\n\n// 接受cat的输入\ncat ./test |grep 'hello'\n\n// 存在路径部分参数\ngrep 'hello' ./test\n")])])]),a("h3",{attrs:{id:"_2-选项部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-选项部分"}},[t._v("#")]),t._v(" 2. 选项部分")]),t._v(" "),a("p",[t._v("选项部分比较多，可以通过grep --help指令来看一下有哪些选项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Regexp selection and interpretation: // 正则表达式选择和解释\n  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n\nMiscellaneous: // 各种各样的\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines // 搜索不匹配的行\n  -V, --version             display version information and exit\n      --help                display this help text and exit\n\nOutput control: // 输出控制\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the file name for each match\n  -h, --no-filename         suppress the file name prefix on output\n      --label=LABEL         use LABEL as the standard input file name prefix\n  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is 'binary', 'text', or 'without-match'\n  -a, --text                equivalent to --binary-files=text\n  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is 'read', 'recurse', or 'skip'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is 'read' or 'skip'\n  -r, --recursive           like --directories=recurse\n  -R, --dereference-recursive  likewise, but follow all symlinks\n      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n\nContext control: // 上下文控制\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is 'always', 'never', or 'auto'\n  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there\n")])])]),a("blockquote",[a("p",[t._v("看着选项内容真的很多，背起来着实不易，幸好文档中给我们做了分类，只需要记住这些分类是干什么的，然后在需要的时候从里面进行搜索即可快速搜寻到所需用法（感觉看其内容必看菜鸟教程上的内容容易很多）")])]),t._v(" "),a("ol",[a("li",[t._v('当需要通过正则的方式进行搜索内容时，去"Regexp selection adn interpretation"区块找选项即可，常用的有')])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-E: 通过正则表达式进行搜索\n\ngrep -E '.*' babel.config.js\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v('当需要对输出的内容进行控制时，去"Output control"区块找选项即可，常用的有如下几个')])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-m 数量:表示匹配多少次就会停止\n-n：显示匹配行及行号\n-H：打印每一个匹配的文件名\n-r：能够递归查询，即可以输入文件夹查询\n-c：统计匹配到行的个数\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v('当需要获取输出内容的上下文进行操纵时，去"Context control"区块找选项即可，常用的有如下几个')])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-B 数量、-A 数量、-C 数量：分别表征获取内容前、后、前后几行\n--color：对输出的内容添加颜色\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[t._v("除了一些划分比较理解的选项，还有一些选项我个人认为划分的并不是很合理，但是它们仍然很重要，让我们一起来看看有哪些：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-i：忽略字母大小写\n-v：反向选择，也就是显示出没有搜索出字符串内容的那一行\n")])])]),a("h2",{attrs:{id:"经典用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#经典用法"}},[t._v("#")]),t._v(" 经典用法")]),t._v(" "),a("p",[t._v("上面已经将其基本使用做了详细的阐述，俗话说的好：光说不练假把式，光练不说真把式，连说带练全把式。既然上面阐述一通理论的东西，下面我们就来实战几个常用场景，将理论付诸于实践。在实战之前先创建一个文件，文件名是test,文件内容如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("hello world!!!\ndog\ncat\npig\nbig pig\ntiger\nElephant\n")])])]),a("ol",[a("li",[t._v("从确定文件中过滤处包含pig的")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep 'pig' ./test\npig\nbig pig\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("从包含某一部分内容的文件中过滤包含pig的")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep 'pig' ./te*\npig\nbig pig\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("从某一个文件夹下所有内容中过滤包含pig的")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep -r 'pig' .\n./test:pig\n./test:big pig\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[t._v("从某一文件中过滤不包含pig的")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep -v 'pig' ./test\nhello world!!!\ndog\ncat \ntiger\nElement\n")])])]),a("ol",{attrs:{start:"5"}},[a("li",[t._v("在过滤文件时显示行数")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep -n 'pig' ./test\n4: pig\n5：big pig\n")])])]),a("ol",{attrs:{start:"6"}},[a("li",[t._v("匹配出以开头的内容(通过基本正则表达式匹配即可，基本正则表达式字符有^$.[]*)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep ^p ./test\npig\n")])])]),a("ol",{attrs:{start:"7"}},[a("li",[t._v("匹配出包含pig或cat内容的行(用到了扩展正则表达式，其在基本正则表达式基础上增加了(){}?+|等)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep -E 'pig|cat' ./test\ncat\npig\nbig pig\n")])])]),a("ol",{attrs:{start:"8"}},[a("li",[t._v("匹配处包含hello和world内容的行")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep 'hello' ./test |grep 'world'\nhello world!!!\n")])])]),a("ol",{attrs:{start:"9"}},[a("li",[t._v("获取到匹配内容‘big pig'的前一行内容")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep -B1 'big pig' ./test\npig\nbig pig\n")])])]),a("ol",{attrs:{start:"10"}},[a("li",[t._v("获取匹配到pig行的数量")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$grep -c 'pig' ./test\n2\n")])])]),a("ol",{attrs:{start:"11"}},[a("li",[t._v("获取到的pig行的内容高亮显示")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ grep --color 'pig' ./test\npig\nbig pig\n")])])]),a("ol",{attrs:{start:"12"}},[a("li",[t._v("Linux在文件夹下查找指定字符串")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("grep "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("rn "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello,world!'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n")])])]),a("ul",[a("li",[t._v("*: 表示当前目录所有文件，也可以是某个文件名")]),t._v(" "),a("li",[t._v("-r 是递归查找")]),t._v(" "),a("li",[t._v("-n 是显示行号")]),t._v(" "),a("li",[t._v("-R 查找所有文件包含子目录")]),t._v(" "),a("li",[t._v("-i 忽略大小写")])]),t._v(" "),a("p",[t._v("下面是一些有意思的命令行参数：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，")])]),t._v(" "),a("li",[a("p",[t._v("grep -l pattern files ：只列出匹配的文件名，")])]),t._v(" "),a("li",[a("p",[t._v("grep -L pattern files ：列出不匹配的文件名，")])]),t._v(" "),a("li",[a("p",[t._v("grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），")])]),t._v(" "),a("li",[a("p",[t._v("grep -C number pattern files ：匹配的上下文分别显示[number]行，")])]),t._v(" "),a("li",[a("p",[t._v("grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，")])]),t._v(" "),a("li",[a("p",[t._v("grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。")])])]),t._v(" "),a("ol",{attrs:{start:"13"}},[a("li",[t._v("查找当前文件夹下的文件")])]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("find")]),t._v(" -name xxxx.js\n")])])]),a("h2",{attrs:{id:"资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/zsFOZZkoqcLBxPLE--3PEg",target:"_blank",rel:"noopener noreferrer"}},[t._v("玩转grep指令"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);