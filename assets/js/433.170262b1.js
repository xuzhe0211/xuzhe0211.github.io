(window.webpackJsonp=window.webpackJsonp||[]).push([[433],{2245:function(n,o,l){"use strict";l.r(o);var t=l(46),a=Object(t.a)({},(function(){var n=this,o=n.$createElement,l=n._self._c||o;return l("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[l("h2",{attrs:{id:"数学中log意思"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数学中log意思"}},[n._v("#")]),n._v(" 数学中log意思")]),n._v(" "),l("p",[n._v("log表示对数")]),n._v(" "),l("p",[n._v("如果a"),l("sup",[n._v("^")]),n._v("n = b （a>0,且a≠1),那么数n叫做以a为底的b的对数，基座n = log(a)b, [a是下标]其中，a叫做底数，b叫做真数")]),n._v(" "),l("h2",{attrs:{id:"o-1-o-n-o-logn-o-nlogn"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#o-1-o-n-o-logn-o-nlogn"}},[n._v("#")]),n._v(" O(1), O(n),O(logn)，O(nlogn)")]),n._v(" "),l("p",[n._v("描述算法复杂度时，常用O(1),O(n),O(logn),O(nlogn)表示对应算法的时间复杂度，是算法的时空复杂度标书。不仅仅用于表示时间复杂度，也用于表示空间复杂度.")]),n._v(" "),l("p",[n._v("O后面的括号中有一个函数，指名某个算法的耗时、耗空间与数据增长量之间的关系。其中n代表输入数据的量。")]),n._v(" "),l("p",[n._v("比如时间复杂度O(n)，就代表数据量增大几倍，耗时有增加几倍。比如常见的遍历算法。再比如时间复杂度O(n"),l("sup",[n._v("^")]),n._v("2),就代表数据量增大n倍时，耗时增大n的平法倍，这是比线性更高的时间复杂度。比如冒泡算法，就是典型的O(n"),l("sup",[n._v("^")]),n._v("2)的算法，对n个数排序，需要扫描n*n次。")]),n._v(" "),l("p",[n._v("在比如O(logn)，当数据增大n倍时，耗时增大logn倍(这里的log是以2为底的，比如当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度)。二分查找就是O(logn)的算法，没中啊一次排除一般的可能，256个数据中查找只需要8次就可以找到目标。")]),n._v(" "),l("p",[n._v("O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大258*8 = 2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度")]),n._v(" "),l("p",[n._v("O(1)就是最低的时间复杂度了，也就是耗时、耗空间与输入的数据大小无关，无论输入数据增大多少倍，耗时、耗空间都不变。哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在依次计算后找到目标(不考虑冲突的话)")])])}),[],!1,null,null,null);o.default=a.exports}}]);