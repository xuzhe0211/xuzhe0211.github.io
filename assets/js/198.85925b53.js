(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{2206:function(e,t,n){"use strict";n.r(t);var s=n(46),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),s("p",[e._v("Koa被认为是第二代node web framework，它最大的特点就是独特的中间件流程控制,是一个典型的洋葱模型。koa和koa2中间件的思路是一样的，但是实现方式有所区别,koa2在node7.6之后更是可以直接用async/await来替代generator使用中间件，本文以最后一种情况举例")]),e._v(" "),s("h2",{attrs:{id:"洋葱模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#洋葱模型"}},[e._v("#")]),e._v(" 洋葱模型")]),e._v(" "),s("p",[e._v("下面两张图是网上找的，很清晰的表情一个请求是如果和经过中间件最后生成响应的，这种模式开发和使用中间件都是非常方便的")]),e._v(" "),s("p",[s("img",{attrs:{src:n(326),alt:"洋葱模型1"}})]),e._v(" "),s("p",[s("img",{attrs:{src:n(327),alt:"洋葱模型2"}})]),e._v(" "),s("p",[e._v("来看一个koa2的demo")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Koa = require('koa');\n\nconst app = new Koa();\nconst PORT = 3000;\n\n// #1\napp.use(async (ctx, next) => {\n    console.log(1);\n    await next();\n    console.log(1);\n})\n// #2\napp.use(async (ctx, next) => {\n    console.log(2);\n    await next();\n    cosnole.log(2);\n})\napp.use(async (ctx, next) => {\n    console.log(3);\n})\n\napp.listen(PORT);\nconsole.log(`http://locaalhost:${PORT}`);\n")])])]),s("p",[e._v("访问http://localhost:3000,控制台打印：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n2\n3\n2\n1\n")])])]),s("p",[e._v("怎么样，是不是有一点点感觉了。当程序运行到await next()的时候就会暂停当前程序，进入下一个中间件，处理完之后才会回过头来继续处理。也就是说,当一个请求进入，#1会被第一个和最后一个经过，#2则是会被第二和倒数第二个经过，一次类推")]),e._v(" "),s("h2",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[e._v("#")]),e._v(" 实现")]),e._v(" "),s("p",[e._v("koa的实现有几个重要的点")]),e._v(" "),s("ol",[s("li",[e._v("context的保存和传递")]),e._v(" "),s("li",[e._v("中间件的管理和next的实现")])]),e._v(" "),s("p",[e._v("翻看源码我们发现")]),e._v(" "),s("p",[e._v("app.listen使用了this.callback来生成node的httpServer的回调函数")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n}\n")])])]),s("p",[e._v("那就再来看this.callback")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("callback() {\n    const fn = compose(this.middleware);\n\n    if (!this.listeners('error').length)  this.on('error', this.onerror);\n\n    const handleRequest = (req, res) => {\n        const ctx = this.createContext(req, res);\n        return this.handleRequest(ctx, fn);\n    }\n    return handleRequest\n}\n")])])]),s("p",[e._v("这里compose处理了一下this.middleware,创建了ctx并赋值为createContext的返回值，最后返回hanldRequest。")]),e._v(" "),s("p",[e._v("this.middleware看起来应该是中间件的集合，查了下代码，果不其然")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("this.middleware = [];\n\n\nuse(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n        deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md'));\n        fn = conver(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n}\n")])])]),s("p",[e._v("抛开兼容和判断，这段代码只做了一件事")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("use(fn) {\n    this.middle.push(fn);\n    return this\n}\n")])])]),s("p",[e._v("原来当我们app.use的时候，只是把方法存在了一个数组里。")]),e._v(" "),s("p",[e._v("那么compose又是什么呢。跟踪源码可以看到compose来自koa-compose模块，代码也不多(去掉了一些不影响主逻辑的判断)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function compose(middleware) {\n    return function(context, next) {\n        let index = -1;\n        return dispatch(0);\n\n        function dispatch(i) {\n            if (i < index) return Promise.reject(new Error('next() called multiple times'));\n            index = i;\n            let fn = middleware[i];\n            if (i === middleware.length) fn = next;\n            if (!fn) return Promise.resolve();\n            try {\n                return Promise.resolve(fn(context, function next() {\n                    return dispatch(i + 1);\n                }))\n            } catch(err) {\n                return Promise.reject(err);\n            }\n        }\n    }\n}\n")])])]),s("p",[e._v("比较关键的就是这个dispatch函数了，它将遍历整个middle，然后将context和dispatch(i + 1)传递给middleware中的方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("return Promise.resolve(fn(context, function next() {\n    return dispath(i + 1);\n}))\n")])])]),s("p",[e._v("这段代码很巧妙的实现了两点")]),e._v(" "),s("ol",[s("li",[e._v("将'context'一路传下去给中间件")]),e._v(" "),s("li",[e._v("将'middleware'中的下一个中间件fn作为未来的next的返回值")])]),e._v(" "),s("p",[e._v("这两点也是洋葱模型实现的核心。")]),e._v(" "),s("p",[e._v("再往下看代码实际上没有太多花样了")]),e._v(" "),s("p",[e._v("createContext和handleRequest做的实际上是把ctx和中间件进行绑定，也就是第一次调用compose返回值的地方")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("createContext(req, res) {\n    const context = Object.create(this.context);\n    const request = context.request = Object.create(this.request);\n    const response = context.response = Object.create(this.reponse);\n    context.app = request.app = response.app = this;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.originalUrl = request.originalUrl = req.url;\n    context.cookies = new Cookies(req, res, {\n      keys: this.keys,\n      secure: request.secure\n    });\n    request.ip = request.ips[0] || req.socket.remoteAddress || '';\n    context.accept = request.accept = accepts(req);\n    context.state = {};\n    return context;\n}\nhandleRequest(ctx, fnMiddleware) {\n    const res = ctx.res;\n    res.statusCode = 404;\n    const onerror = err => ctx.onerror(err);\n    const handleResponse = () => respond(ctx);\n    onFinished(res, onerror);\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror);\n}\n")])])]),s("h2",{attrs:{id:"资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[e._v("#")]),e._v(" 资料")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000013981513",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅析koa的洋葱模型实现"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.cn/post/6893338774088974343",target:"_blank",rel:"noopener noreferrer"}},[e._v("天天造轮子"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports},326:function(e,t,n){e.exports=n.p+"assets/img/2892151181-5ab48de7b5013_fix732.62c210d9.png"},327:function(e,t,n){e.exports=n.p+"assets/img/2474077171-5ab493c984bf8_fix732.ad641f06.png"}}]);