(window.webpackJsonp=window.webpackJsonp||[]).push([[674],{2696:function(a,e,n){"use strict";n.r(e);var t=n(46),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/pnpm/pnpm",target:"_blank",rel:"noopener noreferrer"}},[a._v("pnpm地址"),n("OutboundLink")],1)]),a._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/lerna/lerna",target:"_blank",rel:"noopener noreferrer"}},[a._v("lerna"),n("OutboundLink")],1)]),a._v(" "),n("p",[a._v("主流的包管理工具有pnpm、npm、yarn、lerna")]),a._v(" "),n("h3",{attrs:{id:"什么是lerna"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是lerna"}},[a._v("#")]),a._v(" 什么是lerna")]),a._v(" "),n("p",[a._v("Lerna是一个管理多个npm模块的工具,是Babel自己用来维护自己的Monorepo并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题，可以优化使用git和npm管理夺宝存储库的工作流程。")]),a._v(" "),n("h3",{attrs:{id:"pnpm有哪些特点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm有哪些特点"}},[a._v("#")]),a._v(" pnpm有哪些特点")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("速度快")]),a._v(" "),n("p",[a._v("绝大多数场景下，速度会比npm/yarn快2-3倍")])]),a._v(" "),n("li",[n("p",[a._v("高效利用磁盘空间")]),a._v(" "),n("p",[a._v("内部文件node_modules是从单个可寻址内容的存储连接的")])]),a._v(" "),n("li",[n("p",[a._v("支持monorepo")]),a._v(" "),n("p",[a._v("用一个git仓库来管理多个子项目package")])]),a._v(" "),n("li",[n("p",[a._v("严格")]),a._v(" "),n("p",[a._v("程序包只能访问其中指定的依赖项package.json")])]),a._v(" "),n("li",[n("p",[a._v("确定性")]),a._v(" "),n("p",[a._v("一个名为的锁定文件pnpm-lock.yaml")])])]),a._v(" "),n("h2",{attrs:{id:"lerna"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lerna"}},[a._v("#")]),a._v(" lerna")]),a._v(" "),n("p",[a._v("lerna默认将软件包列表初始化为['package/*'],如下所示:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("录结构如下:\n\npackages/\n├── foo-pkg\n│   └── package.json\n├── bar-pkg\n│   └── package.json\n├── baz-pkg\n│   └── package.json\n└── qux-pkg\n    └── package.json\n")])])]),n("h3",{attrs:{id:"安装lerna"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装lerna"}},[a._v("#")]),a._v(" 安装lerna")]),a._v(" "),n("p",[a._v("由于lerna会经常使用到，所以这里可以采用全局安装")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("npm i -g lerna\n")])])]),n("h3",{attrs:{id:"初始化项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化项目"}},[a._v("#")]),a._v(" 初始化项目")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna init\n")])])]),n("p",[a._v("初始化项目后，我们可以看到package.json & lerna.json如下所示")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('// package.json\n{\n    "name": "root",\n    "provate": true, // 私有的，不会被发布，是管理整个项目，与要发布到的npm的解耦\n    "devDependencies": {\n        "lerna": \'^3.15.0\'\n    }\n}\n\n// lerna.json\n{\n    "packages": [\n        "package/*"\n    ], \n    "version": "0.0.0"\n}\n')])])]),n("h3",{attrs:{id:"创建npm包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建npm包"}},[a._v("#")]),a._v(" 创建npm包")]),a._v(" "),n("p",[a._v("增加两个包@mo-demo/cli @mo-demo/cli-shared-utils")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna create @mo-demo/cli\nlerna create @mo-demo/cli-shared-utils\n")])])]),n("h3",{attrs:{id:"增加模块依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#增加模块依赖"}},[a._v("#")]),a._v(" 增加模块依赖")]),a._v(" "),n("p",[a._v("分别给相应的package增加依赖模块")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna add chalk // 为所有package增加chalk模块\nlerna add semver --scope @mo-demo/cli-shared-utils // 为@mo-demo/cli-shared-utils增加semver模块\nlerna add @mo-demo/cli-shared-utils --scope @mmo-demo/cli // 增加内部模块之间的依赖\n")])])]),n("h3",{attrs:{id:"发布"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发布"}},[a._v("#")]),a._v(" 发布")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna publish\n")])])]),n("h3",{attrs:{id:"依赖包管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖包管理"}},[a._v("#")]),a._v(" 依赖包管理")]),a._v(" "),n("p",[a._v("我们使用--hoist来把每个package下的依赖包都提升到工程根目录，来降低安装以及管理的成本")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna bootstrap --hoist\n")])])]),n("p",[a._v("为了省去每次都输入hoist参数的麻烦，可以在lerna.json配置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('{\n  "packages": [\n    "packages/*"\n  ],\n  "command": {\n    "bootstrap": {\n      "hoist": true\n    }\n  },\n  "version": "0.0.1-alpha.0"\n}\n')])])]),n("p",[a._v("清理之前的安装包，可以使用如下命令")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lerna clean\n")])])]),n("p",[a._v("目前业界有很多团队采用的monorepo解决方案是lerna和yarn的workspaces特性，基于lerna和yarn workspace的monorepo工作流，一般具有以下功能")]),a._v(" "),n("ul",[n("li",[a._v("完善的工作流")]),a._v(" "),n("li",[a._v("typescript支持")]),a._v(" "),n("li",[a._v("风格统一的编码")]),a._v(" "),n("li",[a._v("完整的单元测试")]),a._v(" "),n("li",[a._v("一键式的发布机制")]),a._v(" "),n("li",[a._v("完美的更新日志")])]),a._v(" "),n("h2",{attrs:{id:"pnpm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[a._v("#")]),a._v(" pnpm")]),a._v(" "),n("p",[a._v("常见的目录结构如下")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("node_modules\n├─ foo\n|  ├─ index.js\n|  └─ package.json\n└─ bar\n   ├─ index.js\n   └─ package.json\n")])])]),n("h3",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),n("p",[a._v("pnpm是一种新起的包管理器，从npm下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习")]),a._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),n("ol",[n("li",[a._v("目前，安装效率高于npm和yarn的最新版")]),a._v(" "),n("li",[a._v("极其简介的node_modules目录")]),a._v(" "),n("li",[a._v("避免了开发时使用简介依赖的问题")]),a._v(" "),n("li",[a._v("能极大的降低磁盘空间的占用")])])]),a._v(" "),n("h3",{attrs:{id:"安装和使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装和使用"}},[a._v("#")]),a._v(" 安装和使用")]),a._v(" "),n("p",[a._v("使用pnpm代替npm/Yarn，顺便用pnpx代替npx 命令如下")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("npm install -g pnpm\n\npnpm install\n\npnpx create-react-app my-cool-new-app\n")])])]),n("p",[a._v("之后在使用时，只需要把npm替换成pnpm即可。")]),a._v(" "),n("p",[a._v("如果要执行安装在本地的CLI,可以使用pnpx，它和npx的功能完全一样，唯一不同的是，在使用pnpx执行一个需要安装的命令时，会使用pnpm进行安装。")]),a._v(" "),n("p",[a._v("比如npx mocha执行本地mocha命令时，如果mocha没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令")]),a._v(" "),n("h3",{attrs:{id:"pnpm原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm原理"}},[a._v("#")]),a._v(" pnpm原理")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("同 yarn 和 npm 一样，pnpm 仍然使用缓存来保存已经安装过的包，以及使用 pnpm-lock.yaml 来记录详细的依赖版本。")])]),a._v(" "),n("li",[n("p",[a._v("不同于 yarn 和 npm， pnpm 使用"),n("strong",[a._v("符号链接和硬链接")]),a._v("（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快。")])]),a._v(" "),n("li",[n("p",[a._v("由于使用了"),n("strong",[a._v("符号链接和硬链接")]),a._v("，pnpm可以规避windows操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖。")])])]),a._v(" "),n("h3",{attrs:{id:"pnpm更新包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm更新包"}},[a._v("#")]),a._v(" pnpm更新包")]),a._v(" "),n("p",[a._v("monorepo项目中可以通过--filter来指定package，进而更新包")]),a._v(" "),n("h3",{attrs:{id:"pnpm移除依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm移除依赖"}},[a._v("#")]),a._v(" pnpm移除依赖")]),a._v(" "),n("p",[a._v("monorepo项目中将包从node_modules和pageage.json中移除，如下")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("pnpm uninstall xxx --filter package-a\n")])])]),n("h3",{attrs:{id:"pnpm硬连接项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm硬连接项目"}},[a._v("#")]),a._v(" pnpm硬连接项目")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("pnpm link ../xxxx\n")])])]),n("h2",{attrs:{id:"注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[a._v("#")]),a._v(" 注意事项")]),a._v(" "),n("p",[a._v("由于 pnpm 会改动 node_modules 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 pnpm 安装的包中包含间接依赖，则会出现问题("),n("strong",[a._v("现在不会了，除非使用了绝对路径")]),a._v(")。")]),a._v(" "),n("p",[a._v("由于 pnpm 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码。")]),a._v(" "),n("p",[a._v("我们可以使用pnpm、vite构建工具来实践一下，可以拿vue3、react17弄个demo试试。")]),a._v(" "),n("p",[a._v("pnpm可能不是适用于所有项目或所有堆栈的正确工具，但是如果我们想尝试解决的monorepo相同的问题，我们可以考虑将其作为替代方法")]),a._v(" "),n("h2",{attrs:{id:"资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[a._v("#")]),a._v(" 资料")]),a._v(" "),n("p",[n("a",{attrs:{href:"https://jishuin.proginn.com/p/763bfbd56d14",target:"_blank",rel:"noopener noreferrer"}},[a._v("pnpm、lerna+yarn如何选择"),n("OutboundLink")],1)]),a._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/db3ee301af47",target:"_blank",rel:"noopener noreferrer"}},[a._v("lerna使用指南"),n("OutboundLink")],1)]),a._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/weixin_42278979/article/details/118458638",target:"_blank",rel:"noopener noreferrer"}},[a._v("lerna入门"),n("OutboundLink")],1)]),a._v(" "),n("p",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/373935751",target:"_blank",rel:"noopener noreferrer"}},[a._v("使用 pnpm 构建 Monorepo 项目"),n("OutboundLink")],1)]),a._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/3c49f2420f45",target:"_blank",rel:"noopener noreferrer"}},[a._v("vue3-rollup打包"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);