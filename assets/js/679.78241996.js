(window.webpackJsonp=window.webpackJsonp||[]).push([[679],{2706:function(e,a,s){"use strict";s.r(a);var n=s(46),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("a",{attrs:{href:"https://zacharykwan.com/2018/03/08/webpack%E5%8E%9F%E7%90%86/webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20webpack%E5%AF%B9%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/",target:"_blank",rel:"noopener noreferrer"}},[e._v("原文"),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("一般开发不容易遇到循环依赖的情况，可随着项目达到一定的复杂度后，尤其是依赖关系复杂的大项目，很容易出现循环依赖的情况")]),e._v(" "),s("p",[e._v("这篇文章先说下循环依赖的概念、循环呢依赖在commonjs和ES Module的表现，最后在说一下webpack对循环依赖的处理")])]),e._v(" "),s("h2",{attrs:{id:"何谓循环依赖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何谓循环依赖"}},[e._v("#")]),e._v(" 何谓循环依赖")]),e._v(" "),s("p",[e._v("所谓循环依赖，即比如a脚本d的执行依赖b脚本，而b脚本的执行又依赖a脚本。而世界上Node.js"),s("a",{attrs:{href:"https://nodejs.org/api/modules.html#modules_cycles",target:"_blank",rel:"noopener noreferrer"}},[e._v("官网"),s("OutboundLink")],1),e._v("就给出了循环依赖的例子")]),e._v(" "),s("h3",{attrs:{id:"commonjs规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs规范"}},[e._v("#")]),e._v(" Commonjs规范")]),e._v(" "),s("p",[e._v("a.js")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log('a starting');\nexports.done = false;\nconst b = require('./b.js');\nconsole.log('in a, b.done = %j', b.done);\nexports.done = true;\nconsole.log('a.done');\n")])])]),s("p",[e._v("b.js")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log('b starting');\nexports.done = false;\nconst a = require('./a.js');\nconsole.log('in b, a.donw = %j', a.done);\nexports.done = true;\nconsole.log('b done');\n")])])]),s("p",[e._v("main.js")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log('main starting');\nconst a = require('./a.js');\nconst b = require('./b.js');\nconsole.log()\n")])])]),s("p",[e._v("先不使用webpack打包，先在Node.js环境下运行")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ node main.js\n\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a done = true, b.done = true\n")])])]),s("p",[e._v("在这个例子中，并没有出现死循环的现场，这是由于commonjs规范的两个特性。第一运行时加载，第二缓存已加载的模块。一下是整个流程的分析过程")]),e._v(" "),s("ol",[s("li",[e._v("执行main.js，打印main starting")]),e._v(" "),s("li",[e._v("加载a.js， a.js打印 a starting, 导出a.done为false")]),e._v(" "),s("li",[e._v("a.js加载b.js，由此开始执行b.js，打印b starting,导出b.done为false")]),e._v(" "),s("li",[e._v("b.js加载a.js，因为此前a.js已经加载完毕，这里b.js读取的是a.js的缓存内容，程序并没有跑回去a.js")]),e._v(" "),s("li",[e._v("读取a.js缓存为a.done = false,打印 in b, a.done = false,接着导出b.done为true,打印b done，完成b.js的流程")]),e._v(" "),s("li",[e._v("回到a.js流程，b.done为true，打印 in a, b.done = true,导出a.done为false,打印a done")]),e._v(" "),s("li",[e._v("回到main.js流程，因为b.js已经被加载，所以这里不重复执行b.js。")]),e._v(" "),s("li",[e._v("main.js打印in main, a.done = true, b.done = true.")])]),e._v(" "),s("h3",{attrs:{id:"es-module规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-module规范"}},[e._v("#")]),e._v(" ES Module规范")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// a.mjs\nimport {bar} from './b';\nconsole.log('a.mjs');\nconsole.log(bar);\nexport let foo = 'foo';\n\n//b.mjs\nimport {foo} from './a';\nconsole.log('b.mjs');\nconsole.log(foo);\nexport let bar = 'bar';\n")])])]),s("p",[e._v("在node环境下执行")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ node --experimental-modules a.mjs\n(node:53995) ExperimentalWarning: The ESM module loader is experimental.\nb.mjs\nReferenceError: foo is not defined\n")])])]),s("p",[e._v("这个例子是取自于阮一峰大神"),s("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/module-loader#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 入门"),s("OutboundLink")],1),e._v("教程。在这个ES Module例子中，出现了报错提示ReferenceError: foo is not defined，提示foo变量未定义，这是为什么呢？")]),e._v(" "),s("p",[e._v("以下是阮大神的解释")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后在执行a.mjs。接着执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，从而认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没有定义，因此报错")])]),e._v(" "),s("p",[e._v("说实话，这段话我是反反复复看了很久，研读了很久，一直没搞懂接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。这话的意思。")]),e._v(" "),s("p",[e._v("后来直到我把 a.mjs 改为：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// a.mjs\nimport {bar} from './b';\nconsole.log('a.mjs');\nconsole.log(bar);\nexport var foo = 'foo';\n")])])]),s("p",[e._v("运行结果为：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ node --experimental-modules a.mjs\n(node:56529) ExperimentalWarning: The ESM module loader is experimental.\nb.mjs\nundefined\na.mjs\nbar\n")])])]),s("p",[e._v("区别在于，定义 foo 从 let 改为 var，实现了foo 变量提升，这时候打印 foo 为 undefined。")]),e._v(" "),s("p",[e._v("这时候再结合ES Modules 的特性：ES Modules 模块输出的是值的引用，输出接口动态绑定，在编译时执行。这样是不是可以得出这样的结论：")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("更改后的例子：执行a.mjs,第一句马上加载b.mjs，这时a.mjs被引擎解析为创建了变量提升的foo变量的引用，输出foo变量，foo变量为undefined；然后b.mjs中a.mjs导出的引用复制给了foo。")]),e._v(" "),s("p",[e._v("更改前的例子：执行 a.mjs，第一句马上加载 b.mjs，由于 foo变量使用 let 定义，引擎解析创建了没有任何变量的引用，不输出任何变量；在 b.mjs 把“没有任何变量“赋值给了 foo，这里 foo 当然未定义，所以报错提示 foo 未定义。")])]),e._v(" "),s("h2",{attrs:{id:"webpack对循环依赖的处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack对循环依赖的处理"}},[e._v("#")]),e._v(" webpack对循环依赖的处理")]),e._v(" "),s("p",[e._v("好了，说完循环依赖的概念，那么对于webpack进行项目构建的项目，webpack是否能够预见到循环依赖呢")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ ../../node_modules/.bin/webpack\nHash: 6d7e8b3d767ab90792a7\nVersion: webpack 3.4.0\nTime: 51ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  3.55 kB       0  [emitted]  main\n   [0] ./a.js 163 bytes {0} [built]\n   [1] ./b.js 163 bytes {0} [built]\n   [2] ./index.js 560 bytes {0} [built]\n")])])]),s("p",[e._v("答案是没有的。而且将打包代码执行，其执行结果跟上面的一模一样。失望的 webpack，居然检测不了循环加载。在这里举例的是 commonjs 例子，ES Modules 经试验也展现同样的结果。")]),e._v(" "),s("p",[e._v("但方法总比困难多，在这里推荐使用 webpack 插件 circular-dependency-plugin ，能够检测所有存在循环依赖的地方，尽早检测错误，省去大量 debug 的时间。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" ../../node_modules/.bin/webpack\nHash: 6d7e8b3d767ab90792a7\nVersion: webpack 3.4.0\nTime: 51ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  3.55 kB       0  [emitted]  main\n   [0] ./a.js 163 bytes {0} [built]\n   [1] ./b.js 163 bytes {0} [built]\n   [2] ./index.js 560 bytes {0} [built]\n\nERROR in Circular dependency detected:\na.js -> b.js -> a.js\n\nERROR in Circular dependency detected:\nb.js -> a.js -> b.js\n")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);