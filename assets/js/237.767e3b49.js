(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{1639:function(n,e,t){n.exports=t.p+"assets/img/WechatIMG158.11bee6f6.png"},1640:function(n,e,t){n.exports=t.p+"assets/img/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTAwOTA4MC8yMDIwMDcvMTAwOTA4MC0yMDIwMDcyNDIzMjk0MTgwNi0xMjA3NTAwMTcucG5n.6a8a2911.png"},2711:function(n,e,t){"use strict";t.r(e);var a=t(46),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"rollup体验tree-sharking树摇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rollup体验tree-sharking树摇"}},[n._v("#")]),n._v(" Rollup体验Tree-sharking树摇")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// index.js\nimport {add} from './add.js';\nconsole.log(add(2,4));\n\n// add.js\nexport const add(a, b) => a + b;\n\n// 执行\nrollup src/case01/index.js\n")])])]),a("h2",{attrs:{id:"编译经典过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译经典过程"}},[n._v("#")]),n._v(" 编译经典过程")]),n._v(" "),a("p",[a("img",{attrs:{src:t(1639),alt:"经典编译过程"}})]),n._v(" "),a("p",[a("img",{attrs:{src:t(1640),alt:"经典编译过程"}})]),n._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[n._v("TIP")]),n._v(" "),a("p",[n._v("AST(Abstract Syntax Tree) 抽象语法树 在计算机科学中，或简语法树(Syntax treee),是源代码语法解构的一种抽象表示。它以树状的形式表现变成语言的语法结构，树上的每个节点都表示源代码中的一种解构"),a("a",{attrs:{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://astexplorer.net/"),a("OutboundLink")],1)])]),n._v(" "),a("h2",{attrs:{id:"准备工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#准备工具"}},[n._v("#")]),n._v(" 准备工具")]),n._v(" "),a("h3",{attrs:{id:"magic-string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#magic-string"}},[n._v("#")]),n._v(" Magic-string")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/138322881",target:"_blank",rel:"noopener noreferrer"}},[n._v("为什么eslint没有no-magic-string"),a("OutboundLink")],1)]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var MagicString = require('magic-string');\n\nconst s = new MagicString('export var answer = 42;');\n\nconsole.log('s', s.snip(7).toString);\n\nvar bundle = nnew MagicString.bundle();\n\nbundle.addSource({\n    filename: 'foo.js',\n    content: new MagicString('var answer = 42;')\n})\n\nbundle.addSource({\n    filename: 'bar.js',\n    content: new MagicString('console.log(answer)')\n})\n\n// options are as per `s.generateMap()` above\n\nvar map = bundle.generateMap({\n    file: 'bundle.js',\n    includeContent: true,\n    hires: true\n})\n\nconsole.log(map);\n")])])]),a("p",[n._v("code =》 报错")]),n._v(" "),a("p",[n._v("Sourcemap => sentry => 异常监控平台")]),n._v(" "),a("p",[n._v("webpack插件")]),n._v(" "),a("h3",{attrs:{id:"编译器acorn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译器acorn"}},[n._v("#")]),n._v(" 编译器acorn")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://astexplorer.net/"),a("OutboundLink")],1)]),n._v(" "),a("p",[a("a",{attrs:{href:"https://www.npmjs.com/package/acorn",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.npmjs.com/package/acorn"),a("OutboundLink")],1)]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const acorn = require(\'acorn\');\n\nconsnt walk = require(\'./walk\');\n\nconst code = `\n    import {a} from "./foo";\n    console.log("Hello" + a);\n    console.log("World");\n    export const b = 1\n`\n\nlet ast = acorn.parse(code, {\n    locations: true, // 索引位置\n    ranges: true, \n    sourceType: "module",\n    ecmaVerson: 7\n})\n')])])]),a("h3",{attrs:{id:"语法树访问者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法树访问者"}},[n._v("#")]),n._v(" 语法树访问者")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/**\n* AST语法树遍历\n*\n*/\nfunction walk(ast, {enter, leave}) {\n    visit(ast, null, enter, leave);\n}\n/**\n* 访问者\n* @param {*} node\n* @param {*} parent * @param {*} enter * @param {*} leave * @returns\n*/\nfunction visit(node, parent, enter, leave) {\n    if (!node) return;\n    // 先执行enter\n    if(enter) {\n        enter.call(null, node, parent);\n    }\n\n    let childkeys = Object.keys(node).filter(\n        (key) => typeof node[key] === 'object'\n    );\n\n    childkeys.forEach((childKey) => {\n        let value = node[childKey];\n        if (Array.isArray((val) => visit(val, node, enter, leave))) {\n            value.forEach(val => visit(val, node, enter, leave);)\n        } else {\n            visit(value, node, enter, leave);\n        }\n    })\n\n    if (leave) {\n        leave(node, parent);\n    }\n}\n\nmodule.exports = walk;\n")])])]),a("p",[n._v("Ast遍历")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let indent = 0;\nconst padding = () => ' '.repeat(indent);\n\n// 遍历语法树中的每一条语句，由walk遍历子元素\n// 深度优先原则\nast.body.forEach(statement => {\n    walk(statement, {\n        enter(node) {\n            if (node.type) {\n                console.log(paddinng() + node.type + ' enter');\n                indent += 2;\n            }\n        }, \n        leave(node) {\n            if (node.tpye) {\n                indent -= 2;\n                console.log(padding() + node.type + ' leave');\n            }\n        }\n    })\n})\n")])])]),a("h3",{attrs:{id:"作用域描述对象scope"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域描述对象scope"}},[n._v("#")]),n._v(" 作用域描述对象Scope")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/**\n* 模拟作用域链 \n*/\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent // 父作用域\n        this.depth = this.parent ? this.parent.depth + 1 : 0 // 作用域层级\n        this.names = options.params || [] // 作用域内的变量\n        this.isBlockScope = !!options.block // 是否块作用域\n    }\n    /**\n    * 将变量添加到作用域\n    * @param {*} name\n    * @param {*} isBlockDeclaration */\n    add(name, isBlockDeclaration) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n\n            // it's a `var` or function declaration, and this // is a block scope, so we need to go up this.parent.add(name, isBlockDeclaration)\n        } else {\n            this.names.push(name)\n        }\n    }\n    /**\n    * 判断变量是否被声明 * @param {*} name * @returns\n    */\n    cantains(name) {\n        return !!this.findDefiningScope(name)\n    }\n    /**\n    * 返回变量坐在的作用域 * @param {*} name * @returns\n    */\n    findDefiningScope(name) {\n        if (this.names.includes(name)) {\n            return this\n        }\n        if (this.parent) {\n            return this.parent.findDefiningScope(name)\n        }\n        return null\n    }\n}\nmodule.exports = Scope\n")])])]),a("h2",{attrs:{id:"原型系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型系统"}},[n._v("#")]),n._v(" 原型系统")]),n._v(" "),a("p",[n._v("Parse阶段")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(' \nconst acorn = require("acorn");\nconst walk = require("../../lib/ast/walk");\nconst Scope = require("../../lib/ast/scope");\nconst MagicString = require("magic-string");\nconst code = {\n    index: `import { add } from "./add.js"; console.log(add(2, 4));`,\n    add: `export const add = (a,b) => a + b `,\n}\n')])])]),a("p",[n._v("Import 分析")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(' \nfunction getImports(ast) {\n    console.log("========分析import=======");\n    const imports = {};\n    ast.body.forEach((node) => {\n        if (node.type === "ImportDeclaration") {\n            console.log("import:", node._source.toString()); \n            // ex: import { a : b } from \'foo\'\n            // let source = node.source.value;\n            const source = "";\n            let specifiers = node.specifiers;\n            specifiers.forEach((specifier) => {\n                const name = specifier.imported.name; // a\n                const localName = specifier.local.name; // b\n                console.log("specifiers", name, localName);\n                imports[localName] = { name, localName, source };\n            });\n        }\n    });\n  return imports;\n}\n')])])]),a("p",[n._v("Export 分析")]),n._v(" "),a("p",[n._v("语法分析")]),n._v(" "),a("ul",[a("li",[n._v("变量定义")]),n._v(" "),a("li",[n._v("变量依赖")]),n._v(" "),a("li",[n._v("语句")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(' \n// 分析函数\nfunction analyse(ast, magicString) {\n    console.log("======analyse====="); // 创建全局作用域\n    let scope = new Scope();\n    // 遍历当前语法树\n     \n    ast.body.forEach((statement) => {\n        /**\n        * 给作用域内添加变量\n        * @param {*} declaration */\n        function addToScope(declaration) {\n            var name = declaration.id.name; // 获取声明的变量\n            scope.add(name);\n            if (!scope.parent) {\n                // 如果此变量作用域不在父级作用域 即当前作用域 // 如果当前是全局作用域的话\n                // 在全局作用域下声明全局变量 statement._defines[name] = true;\n            }\n        }\n\n        Object.defineProperties(statement, {\n            // 变量定义\n            _defines: { value: {} },\n\n            // 变量依赖\n            _dependsOn: { value: {} },\n\n            // 此语句是否被打包Bundle 防止多次打包Bundle \n            _included: { value: false, writable: true },\n\n            // 变量语句\n            _source: { value: magicString.snip(statement.start, statement.end) },\n        });\n        // 作用域链遍历\n        // 分析变量定义的\n        // 构造作用域链\n        walk(statement, {\n            enter(node) {\n                let newScope;\n                // 防止空节点和空数组\n                if (node === null || node.length === 0) return;\n                switch (node.type) {\n                    // 变量声明\n                    case "VariableDeclaration":\n                        declarations.push(node);\n                        node.declarations.forEach(addToScope);\n                        break;\n                }\n                 if (newScope) {\n                    console.log("newScope", newScope); \n                    // 当前节点声明的新作用域\n                    // 如果此节点生成一个新作用域\n                     \n                    Object.defineProperties(node, { _scope: { value: newScope } });\n                    scope = newScope;\n                }\n            },\n            leave(node) {\n                if (node._scope) {\n                    // 如果此节点离开退回父作用域\n                    scope = scope.parent;\n                }\n            },\n        })\n    })\n\n    ast._scope = scope;\n\n    // 找出外部依赖关系 dependsOn \n    ast.body.forEach((statement) => {\n        walk(statement, {\n            enter(node) {\n                if (node._scope) {\n                    scope = node._scope;\n                }\n                // 遇到导出节点\n                if (node.type === "Identifier") {\n                    // 遇到 exports const a => node.name = \'a\'\n\n                    // 向上递归\n                    const definingScope = scope.findDefiningScope(node.name); \n                    if (!definingScope) {\n                        console.log("Identifier:", node.name);\n                        statement._dependsOn[node.name] = true; // 表示属于外部依赖变量\n                    }\n                }\n            },\n            leave(node) {\n                if (node._scope) scope = scope.parent;\n            },\n        });\n    });\n})\n')])])]),a("p",[n._v("语句扩展添加声明")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('let declarations = [];\nanalyse(add, new MagicString(code.add));\nanalyse(index, new MagicString(code.index)); // 追加\nconst statments = expandAllStatements(index);\n \n/**\n* 展开所有语句节点 * @returns\n*/\nfunction expandAllStatements(ast) {\n    console.log("=========expandAllStatements============="); const allStatements = [];\n    ast.body.forEach((statement) => {\n        // 忽略所有Import语句\n        if (statement.type === "ImportDeclaration") {\n            return;\n        }\n        allStatements.push(...declarations, statement);\n    });\n    return allStatements;\n}\n')])])]),a("p",[n._v("generate阶段")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \nfunction generate(statments) {\n    console.log('======generate=====')\n    // statments.forEach(v => console.log(magicString.snip(v.start, v.end))) let v = statments[0]\n    console.log(new MagicString(code.add).snip(v.start, v.end).toString())\n    v = statments[1]\n    console.log(new MagicString(code.index).snip(v.start, v.end).toString())\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);