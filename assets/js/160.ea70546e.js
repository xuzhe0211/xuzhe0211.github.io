(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{2264:function(t,e,n){"use strict";n.r(e);var r=n(46),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("算法逻辑思维？")]),t._v(" "),r("p",[t._v("大厂工程师的自我修改")]),t._v(" "),r("ul",[r("li",[t._v("新手篇：在基础数据解构与算法中精进\n"),r("ul",[r("li",[t._v("线性表基础")]),t._v(" "),r("li",[t._v("树结构基础")]),t._v(" "),r("li",[t._v("排序算法")]),t._v(" "),r("li",[t._v("查找与搜索")])])]),t._v(" "),r("li",[t._v("高手篇：数据结构与算法进阶")]),t._v(" "),r("li",[t._v("极客：走进伟大的算法思想")])]),t._v(" "),r("p",[t._v("线性表基础--链表\n树结构--简单的树结构题（遍历，相等 ，二叉树反转操作）\n排序--快排、归并排序(相关优化)调用排序算法\n查找与搜索--二分查找、hash(哈希)表（一个算法，一个结构） 搜索--深搜、广搜")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("时间复杂度")]),t._v(" "),r("th",[t._v("链表")]),t._v(" "),r("th",[t._v("数组")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("插入")]),t._v(" "),r("td",[t._v("O(n)")]),t._v(" "),r("td",[t._v("O(1)")])]),t._v(" "),r("tr",[r("td",[t._v("删除")]),t._v(" "),r("td",[t._v("O(1)")]),t._v(" "),r("td",[t._v("O(n )")])]),t._v(" "),r("tr",[r("td",[t._v("查找")]),t._v(" "),r("td",[t._v("O(1)")]),t._v(" "),r("td",[t._v("O(n)")])])])]),t._v(" "),r("h2",{attrs:{id:"链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),r("h3",{attrs:{id:"删除链表中的倒数第n个节点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除链表中的倒数第n个节点"}},[t._v("#")]),t._v(" 删除链表中的倒数第N个节点")]),t._v(" "),r("p",[t._v("虚拟头节点-- 删除头节点？")]),t._v(" "),r("p",[r("img",{attrs:{src:n(665),alt:"指针移动"}})]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class Solution {\npublic: \n    ListNode* removeNthFromEnd(ListNode* head, init i) {\n        listNode ret, *p, *q;\n        ret.next = head;\n        p = &ret; q = head;\n        while(n--) q = q -> next;\n        whidle(q)  p = p -> next, q = q-> next;\n        p -> next = p -> next -> next;\n        return ret. next;\n    }\n}\n")])])]),r("h3",{attrs:{id:"判断链表是否为回文链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断链表是否为回文链表"}},[t._v("#")]),t._v(" 判断链表是否为回文链表")]),t._v(" "),r("p",[t._v("1-> 2 false")]),t._v(" "),r("p",[t._v("1-> 2->2 -> 1 true")]),t._v(" "),r("p",[r("img",{attrs:{src:n(666),alt:"反转实现"}})]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class Solution {\npublic: \n    init getLen(ListNode *head) {\n        ListNode *p = head;\n        int l = 0;\n        while (p) p = p -> next, l += 1;\n        return l\n    }\n\n    ListNode * reverse(listNode, *head) {\n        listNode ret, *p, *q;\n        ret.next = nullptr;\n        p = head;\n        while(p) {\n            q = p -> next;\n            p-> next = ret.next;\n            ret.next = p;\n            p = q;\n        }\n        return ret.next;\n    }\n\n    bool inPalindrome(ListNode* head) {\n        int = n = getLen(head);\n        int m = n / 2;\n        listNode ret, *p, * q;\n        ret.next = head;\n        p = &ret, q = head;\n        while(m--) q = q -> next;\n        while (q) p = p -> next, q = q.next;\n        p -> next = reverse(p -> next);\n        p = p -next;\n        q = head;\n        while(p) {\n            if(p -> val - q ->val)  return false;\n            p = p -> next;\n            q = q -> next;\n        }\n        return false;\n    }\n}\n")])])]),r("h2",{attrs:{id:"二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),r("h3",{attrs:{id:"二叉树的层序遍历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的层序遍历"}},[t._v("#")]),t._v(" 二叉树的层序遍历")]),t._v(" "),r("ol",[r("li",[t._v("广度遍历")]),t._v(" "),r("li",[t._v("深搜实现")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class Solution {\npublic: \n    void dfs(ThreeNode *root, int k, vector<vector<int>> &ret) {\n        if (root === nullptr) return;\n        if (ret.size() === k) ret.push_back(vector<int>()); // 新的数组  动态扩容数组\n        ret[k].push_back(root -> val);\n        dfs(root-> left, k + 1, ret);\n        dfs(root -> right, k + 1, ret);\n        return;\n    }\n    vector<vector<int>> levelOrder(ThreeNode* root) {\n        vector<vector<int>> ret;\n        dfs(root, 0, ret);\n        return ret;\n    }\n}\n")])])]),r("h3",{attrs:{id:"平衡二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[t._v("#")]),t._v(" 平衡二叉树")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class Solution {\npublic: \n    int getHeight(TreeNode *root) {\n        if (root == nullprt) return 0;\n        int l = getHeight(root->left);\n        int r = getHeight(root->right);\n        if (l < 0 || r < 0) return -2;\n        if (abs(l - r) > 1) return -2;\n        return max(l, r) + 1;\n    }\n    bool isBalanced(TreeNode* root) {\n        int h = getHeight(root);\n        return h >= 0;\n    }\n}\n")])])]),r("p",[r("img",{attrs:{src:n(667),alt:"课后练习"}})])])}),[],!1,null,null,null);e.default=a.exports},665:function(t,e,n){t.exports=n.p+"assets/img/WechatIMG166.266da409.png"},666:function(t,e,n){t.exports=n.p+"assets/img/WechatIMG167.317fb286.png"},667:function(t,e,n){t.exports=n.p+"assets/img/WechatIMG168.952ee56a.png"}}]);