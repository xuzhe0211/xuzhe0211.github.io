(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{2282:function(s,t,a){"use strict";a.r(t);var e=a(46),c=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"背景介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#背景介绍"}},[s._v("#")]),s._v(" 背景介绍")]),s._v(" "),e("p",[s._v("从第五代标准HTML推广发布后，其中工作线程(Web Worker)概念的推出让人眼前一亮，但未曾随之激起多大的浪花，并被在其随后的工程侧Angular、Vue、React等框架的浪潮淹没")]),s._v(" "),e("p",[s._v("微前端的概念自从火爆以来，对于JS隔离和css的隔离成为了众多开发者的解决的主要方向")]),s._v(" "),e("h2",{attrs:{id:"什么是css隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是css隔离"}},[s._v("#")]),s._v(" 什么是CSS隔离")]),s._v(" "),e("p",[s._v("css一旦生效，就会应用于全局，所以很容易出现冲突。css隔离就是为了解决这个问题。")]),s._v(" "),e("p",[s._v("当我们作为前端开发人员较长一段时间后，我们很轻易地就能想到为什么需要css隔离，抛弃微前端的概念不谈，就算当前流行的前端框架也在解决css隔离的路上做出了相应的动作，其中就有Vue，虽然React并没有对css隔离做处理，但是React关于这方面的插件也不少，开源的解决方案也特别多.")]),s._v(" "),e("h3",{attrs:{id:"css隔离条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css隔离条件"}},[s._v("#")]),s._v(" css隔离条件")]),s._v(" "),e("p",[s._v("既然有需求就应该提出符合的要求---"),e("span",{staticStyle:{color:"blue"}},[s._v("css隔离是将css样式通过特殊方法安置在独立环境中，暂时避免和其他CSS污染")])]),s._v(" "),e("h3",{attrs:{id:"css隔离的几种方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css隔离的几种方式"}},[s._v("#")]),s._v(" css隔离的几种方式")]),s._v(" "),e("p",[s._v("市面上大体上来说有三种，都能更好的实现CSS隔离的要求")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("第一种："),e("RouterLink",{attrs:{to:"/source-react/react-tips-css.html"}},[s._v("CSS in js")])],1),s._v(" "),e("p",[s._v("这个概念是facebook提出的，最初呢？有一个观点叫做关注点分离，它的意思是，各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术隔离")]),s._v(" "),e("p",[e("img",{attrs:{src:a(741),alt:"html"}})]),s._v(" "),e("blockquote",[e("p",[s._v("HTML语言:负责网页的结构，又称语义层\nCSS语言:负责网页的样式，又称为视觉层\nJavaScript语言:负责网页的逻辑与交互，又称逻辑层或者交互层")])]),s._v(" "),e("p",[s._v('简单说，就是一句话，不要写"行内样式"（inline style）和"行内脚本"（inline script）。')]),s._v(" "),e("p",[s._v("React 出现以后，这个原则不再适用了。因为，React 是组件结构，强制要求把 HTML、CSS、JavaScript 写在一起。")]),s._v(" "),e("p",[s._v('但是实际上，React只能说是用js在写css，它封装了结构、样式和逻辑，完全违背了"关注点分离"的原则，但是它更利于组件之间的隔离，对于组件概念更加友好。')]),s._v(" "),e("p",[s._v("由于 CSS 的封装非常弱，导致了一系列的第三方库，用来加强 React 的 CSS 操作。它们统称为 CSS in JS，意思就是使用 JS 语言写 CSS。根据不完全统计，各种 CSS in JS 的库层出不穷。但是我觉得，这种方式不会成为主流隔离方式，一方面对于第三方库的长期维护是一个问题，再加上封装的水平也是个问题")])]),s._v(" "),e("li",[e("p",[s._v("第二种；CSS Module")]),s._v(" "),e("p",[s._v("Vue大概就是这种方案，理解起来很简单，给每一个dom都给了一个独立的Hash，对于上面所挂在的CSS样式通过改hash绑定即可，没什么好说的，现在打包工具这么完善，借助打包工具很轻松的就能实现这种代码")])]),s._v(" "),e("li",[e("p",[s._v("第三种:shadow DOM")]),s._v(" "),e("p",[e("span",{staticStyle:{color:"blue"}},[s._v("Web Component的一个重要属性是封装--可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可实代码更加干净、整洁。其中，Shadow DOM接口是关键所在，它可以将一个隐藏的、独立的DOM附加到一个元素上。")])]),s._v(" "),e("p",[s._v("再举一个例子，拿video标签来说，对于外部来说，它只是一个video标签而已，但是实际上你把video展开来看，其实里面包含了很多dom结构。如图所示：")]),s._v(" "),e("p",[e("img",{attrs:{src:a(742),alt:"video"}})]),s._v(" "),e("p",[e("img",{attrs:{src:a(743),alt:"video"}})]),s._v(" "),e("p",[s._v("可以很容易的看得出来，这里的video就是封装好的一个组件。这对于我们来说不是天然的组件容器吗？")])])]),s._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),e("p",[e("img",{attrs:{src:a(744),alt:"总结"}})]),s._v(" "),e("h2",{attrs:{id:"资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[s._v("#")]),s._v(" 资料")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/u013605060/article/details/119994137",target:"_blank",rel:"noopener noreferrer"}},[s._v("关于css隔离的几种方案带来的思考和展望"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=c.exports},741:function(s,t,a){s.exports=a.p+"assets/img/c54efd841c074a99a1b32e6f7ae0bca0.45af430f.png"},742:function(s,t,a){s.exports=a.p+"assets/img/aadcb312b9e74444914c9ae2e855b8cd.e56bac87.png"},743:function(s,t,a){s.exports=a.p+"assets/img/afe48825b89b40989dcd05cb4ee083e8.e090ad88.png"},744:function(s,t,a){s.exports=a.p+"assets/img/66df41862c3b4c5aa6b966efb6424b3e.7c363f1d.png"}}]);