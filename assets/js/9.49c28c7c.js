(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{1283:function(t,s,a){t.exports=a.p+"assets/img/ts1.58ebd4a5.png"},1284:function(t,s,a){t.exports=a.p+"assets/img/ts02.9188415a.jpg"},1285:function(t,s,a){t.exports=a.p+"assets/img/ts03.a368db5b.jpg"},1286:function(t,s,a){t.exports=a.p+"assets/img/ts04.72eda236.jpg"},1287:function(t,s,a){t.exports=a.p+"assets/img/ts05.d40c61c9.jpg"},1288:function(t,s,a){t.exports=a.p+"assets/img/babel01.9a2d1878.png"},1289:function(t,s,a){t.exports=a.p+"assets/img/babel02.5725d412.jpg"},1290:function(t,s,a){t.exports=a.p+"assets/img/babel03.6af985d7.jpg"},1291:function(t,s,a){t.exports=a.p+"assets/img/babel04.419a65f9.jpg"},1292:function(t,s,a){t.exports=a.p+"assets/img/ts06.ba46938b.jpg"},1293:function(t,s,a){t.exports=a.p+"assets/img/ts07.33ce1324.jpg"},1294:function(t,s,a){t.exports=a.p+"assets/img/ts08.df071f52.jpg"},1295:function(t,s,a){t.exports=a.p+"assets/img/ts09.ce5e10ab.jpg"},1296:function(t,s,a){t.exports=a.p+"assets/img/ts10.6880a550.jpg"},1297:function(t,s,a){t.exports=a.p+"assets/img/ts11.999a39b9.jpg"},1298:function(t,s,a){t.exports=a.p+"assets/img/ts12.f9c8d06b.jpg"},1299:function(t,s,a){t.exports=a.p+"assets/img/ts-namespace02.ee5ada81.jpg"},1300:function(t,s,a){t.exports=a.p+"assets/img/ts-namespace01.3eead553.jpg"},1301:function(t,s,a){t.exports=a.p+"assets/img/ts-namespace03.b2d5a21a.jpg"},1302:function(t,s,a){t.exports=a.p+"assets/img/babel-import.7d698d37.jpg"},1303:function(t,s,a){t.exports=a.p+"assets/img/ts-as01.0f0c8c9e.jpg"},1304:function(t,s,a){t.exports=a.p+"assets/img/ts-as02.21c9dceb.jpg"},1305:function(t,s,a){t.exports=a.p+"assets/img/babel-as.6375206c.jpg"},2566:function(t,s,a){"use strict";a.r(s);var e=a(46),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("编译TypeScript代码用什么编译器？")]),t._v(" "),e("p",[t._v("那还用说，肯定是ts自带的compiler。")]),t._v(" "),e("p",[t._v("但其实babel也能编译ts代码，那用babel和tsc编译ts有什么区别呢？")]),t._v(" "),e("p",[t._v("我们分别来看一下")]),t._v(" "),e("h2",{attrs:{id:"tsc的编译流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tsc的编译流程"}},[t._v("#")]),t._v(" tsc的编译流程")]),t._v(" "),e("p",[t._v("typescript compiler的编译流程是这样的")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1283),alt:"typeScript compiler"}})]),t._v(" "),e("p",[t._v("源码要先用Scanner进行词法分析，拆分成一个个不能细分的单词，叫做token。")]),t._v(" "),e("p",[t._v("然后Parser进行语法分析，组装成抽象语法树(Abstract Syntax Tree)AST;")]),t._v(" "),e("p",[t._v("之后做语义分析，包括用binder进行作用域分析，和有Checker做类型检查。如果有类型的错误，就是在Cheker这个阶段报的。")]),t._v(" "),e("p",[t._v("如果有Transformer插件(tsc支持custom transform),会在Checker之后调用，可以对AST做各种增删改")]),t._v(" "),e("p",[t._v("类型检查通过后就会用Emmiter把AST打印成目标代码，生成类型声明文件d.ts，还有sourcemap")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("sourcemap的作用是映射源码和目标代码的代码位置，这样调试的时候打断点可以定位到相应的源码。线上报错的时候也能更加sourcemap定位源码报错的位置")])]),t._v(" "),e("p",[t._v("tsc生成AST可以用astexplorer.net可视化的查看")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1284),alt:"astexplorer"}})]),t._v(" "),e("p",[t._v("生成的目标代码和 d.ts 和报错信息也可以用 ts playground 来直接查看：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1285),alt:"生成目标js"}}),t._v(" "),e("img",{attrs:{src:a(1286),alt:"生成目标d.ts"}}),t._v(" "),e("img",{attrs:{src:a(1287),alt:"生成目标"}})]),t._v(" "),e("p",[t._v("大概了解了 tsc 的编译流程，我们再来看下 babel 的：")]),t._v(" "),e("h2",{attrs:{id:"babel的编译流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel的编译流程"}},[t._v("#")]),t._v(" babel的编译流程")]),t._v(" "),e("p",[t._v("babel的编译流程是这样的：\n"),e("img",{attrs:{src:a(1288),alt:"babel编译流程"}})]),t._v(" "),e("p",[t._v("源码经过Parser做词法分析和语法分析，生成token和AST")]),t._v(" "),e("p",[t._v("AST会做语义分析生成作用域信息，然后调用Transformer进行AST转换。")]),t._v(" "),e("p",[t._v("最后会用 Generator把AST打印成目标代码并生成sourcemap。")]),t._v(" "),e("p",[t._v("babel的AST和Token也可以用astexplorer.net可视化查看")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1289),alt:"astexplorer"}})]),t._v(" "),e("p",[t._v("如果想看到 tokens，需要点开设置，开启 tokens：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1290),alt:"token"}})]),t._v(" "),e("p",[t._v("而且 babel 也有 playground（babel 的叫 repl） 可以直接看编译之后生成的代码：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1291),alt:"babel playground"}})]),t._v(" "),e("p",[t._v("其实对比下tsc的编译流程，区别不大")]),t._v(" "),e("p",[t._v("Parser对应tsc的Scanner和Parser，都是做词法分析和语法分析，只不过babel没有细分")]),t._v(" "),e("p",[t._v("Transform阶段做语义和代码转换，对应tsc的Binder和Transformer。"),e("span",{staticStyle:{color:"blue"}},[e("strong",[t._v("只不过babel不会做类型检查，没有Checker")])])]),t._v(" "),e("p",[t._v("Generator做目标代码和sourcemap，对应的tsc的Emmiter。"),e("span",{staticStyle:{color:"blue"}},[e("strong",[t._v("只不过没有类型信息，不会生成d.ts")])])]),t._v(" "),e("p",[t._v("对比两者的编译流程，会发现babel除了不做类型检查和生成类型声明之外，tsc能做的事情，babel都能做。")]),t._v(" "),e("p",[t._v("看起来好像是这样，但是baben和tsc实现这些功能还是有区别的")]),t._v(" "),e("h2",{attrs:{id:"babel和tsc的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel和tsc的区别"}},[t._v("#")]),t._v(" babel和tsc的区别")]),t._v(" "),e("p",[t._v("抛开类型检查和生成d.ts这两babel不支持的功能不谈，我们看下其他功能的对比，")]),t._v(" "),e("p",[t._v("分别对比下语法支持和代码生成两方面")]),t._v(" "),e("h3",{attrs:{id:"语法支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法支持"}},[t._v("#")]),t._v(" 语法支持")]),t._v(" "),e("p",[t._v("tsc默认支持最新的es规范的语法和一些还在草案阶段的语法(比如decorators)，想支持新语法就要生成tsc版本")]),t._v(" "),e("p",[t._v("babel是通过@babel/preset-env按照目标环境targets的配置自动引入需要用到的插件来支持标准语法，对于还在草案阶段的语法需要单独引入@babel/proposal-xxx的插件来支持。")]),t._v(" "),e("p",[t._v("所以如果只是用标准语法，那用tsc或者babel都行，但是如果想用一些草案阶段的语法，tsc可能很多都不支持，而babel却可以引入@babel/proposal-xx的插件来支持。")]),t._v(" "),e("p",[t._v("从支持语法特性上来说，babel更多一些")]),t._v(" "),e("h3",{attrs:{id:"代码生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码生成"}},[t._v("#")]),t._v(" 代码生成")]),t._v(" "),e("p",[t._v("tsc生成没有做polyfill的处理，想做兼容就需要在入口引入一下core-js(polyfill实现)")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'core-js'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nPromise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("resolve\n")])])]),e("p",[t._v("babel的@babel-parset-env可以根据targets的配置来自动引入需要的插件，引入需要用到的core-js模块")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1292),alt:"ts"}})]),t._v(" "),e("p",[t._v("引入方式可以通过 useBuiltIns 来配置：")]),t._v(" "),e("p",[t._v("entry是在入口引入根据targets过滤处的所有需要用的core-js.")]),t._v(" "),e("p",[t._v("usage则是每个模块按照使用到了哪些来按需引入")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    presets"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@babel/preset-typescript'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@babel/preset-env'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                targets"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'目标环境'")]),t._v("，\n                useBuiltIns"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'entry'")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// usage")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("此外，babel会注入一些helper代码，可以通过@babel/plugin-transform-runtime插件抽离出来，从@babel/runtime包引入")]),t._v(" "),e("p",[t._v("使用transform-runtime之前\n"),e("img",{attrs:{src:a(1293),alt:"ts"}})]),t._v(" "),e("p",[t._v("使用transform-runtime之后\n"),e("img",{attrs:{src:a(1294),alt:"ts"}})]),t._v(" "),e("blockquote",[e("p",[t._v("transform runtime顾名思义就是transform to runtime，转换从runtime包引入heler代码的方法")])]),t._v(" "),e("p",[t._v("所以一般babel都会这么配")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    presets"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@babel/preset-typescript'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@babel/preset-env'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                targets"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'目标环境'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                useBuiltIns"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'usage'")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ‘entry’")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    plugins"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@babel/plugin-transform-runtime'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("当然，这里不是讲 babel 怎么配置，我们绕回主题，babel 和 tsc 生成代码的区别：")]),t._v(" "),e("p",[e("span",{staticStyle:{color:"blue"}},[e("strong",[t._v("tsc 生成的代码没有做 polyfill 的处理，需要全量引入 core-js，而 babel 则可以用 @babel/preset-env 根据 targets 的配置来按需引入 core-js 的部分模块，所以生成的代码体积更小。")])])]),t._v(" "),e("p",[t._v("看起来用 babel 编译 ts 代码全是优点？")]),t._v(" "),e("p",[t._v("也不全是，babel 有一些 ts 语法并不支持：")]),t._v(" "),e("h2",{attrs:{id:"babel不支持的ts语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel不支持的ts语法"}},[t._v("#")]),t._v(" babel不支持的ts语法")]),t._v(" "),e("p",[t._v("babel是每个文件单独编译的，而tsc不是，tsc是整个项目一起编译，会处理类型声明文件，会做跨文件的类型声明合并，比如namespace和interface就可以跨文件合并。")]),t._v(" "),e("p",[t._v("所以babel编译ts代码有一些特性是没法支持的")]),t._v(" "),e("h3",{attrs:{id:"const-enum不支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#const-enum不支持"}},[t._v("#")]),t._v(" const enum不支持")]),t._v(" "),e("p",[t._v("enum编译之后是这样的：\n"),e("img",{attrs:{src:a(1295),alt:"enum编译"}})]),t._v(" "),e("p",[t._v("而const enum编译之后是直接替换用到enum的地方为对应的值，是这样的：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1296),alt:"enum编译之后"}})]),t._v(" "),e("p",[e("span",{staticStyle:{color:"blue"}},[t._v("const enum是在编译期间把enum的引用替换成具体的值，需要解析类型信息，而babel并不会解析，所以它会把const enum转换成enum来处理")]),t._v(" "),e("img",{attrs:{src:a(1297),alt:"babel解析"}})]),t._v(" "),e("h3",{attrs:{id:"namespace部分支持-不支持namespace的合并-不支持导出非const的值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#namespace部分支持-不支持namespace的合并-不支持导出非const的值"}},[t._v("#")]),t._v(" namespace部分支持:不支持namespace的合并，不支持导出非const的值")]),t._v(" "),e("p",[t._v("比如这样一段ts代码：")]),t._v(" "),e("div",{staticClass:"language-ts extra-class"},[e("pre",{pre:!0,attrs:{class:"language-ts"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" Guang "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" name "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'guang'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" Guang "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" name2 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Guange"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name2"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("按理说Guange.name2 是「dong」,因为ts会自动合并同名namespace")]),t._v(" "),e("p",[t._v("ts编译之后的代码是这样：\n"),e("img",{attrs:{src:a(1298),alt:"namespace合并"}})]),t._v(" "),e("p",[t._v("都挂到了Guang这个对象上，所以name2就能取到name的值")]),t._v(" "),e("p",[t._v("而babel对每个namespace都是单独处理的，所以是这样\n"),e("img",{attrs:{src:a(1299),alt:"namespace-bable"}})]),t._v(" "),e("p",[t._v("因为不会做namespace的合并，所以name为undefined。")]),t._v(" "),e("p",[t._v("还有namespace不支持导出非const得值")]),t._v(" "),e("p",[t._v("ts的namespace是可以导出const的值的，后面可以修改\n"),e("img",{attrs:{src:a(1300),alt:"支持导出const的值"}})]),t._v(" "),e("p",[t._v("但babel并不支持\n"),e("img",{attrs:{src:a(1301),alt:"babel不支持导出const的值"}})]),t._v(" "),e("p",[t._v("原因也是因为不会做namespace的解析，而namespace是全局的，如果在另一个文件修改了namespace导出的值，babel并不能处理。所以不支持namespace导出的做修改")]),t._v(" "),e("p",[t._v("除此之外，还有一些语法也不支持")]),t._v(" "),e("h3",{attrs:{id:"部分语法不支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#部分语法不支持"}},[t._v("#")]),t._v(" 部分语法不支持")]),t._v(" "),e("p",[t._v("像export = import = 这种过时的模块语法并不支持\n"),e("img",{attrs:{src:a(1302),alt:"export/import"}})]),t._v(" "),e("p",[t._v("开启了jsx编译之后，不能用尖括号的方式做类型断言")]),t._v(" "),e("p",[t._v("我们知道，ts是可以做类型断言来修改某个类型到某个类型的，用as xx 或者尖括号的方式\n"),e("img",{attrs:{src:a(1303),alt:"as xxx"}})]),t._v(" "),e("p",[t._v("但是如果开启了 jsx 编译之后，尖括号的形式会和 jsx 的语法冲突，所以就不支持做类型断言了：\n"),e("img",{attrs:{src:a(1304),alt:"jsx编译开启后"}})]),t._v(" "),e("p",[t._v("tsc 都不支持，babel 当然也是一样：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1305),alt:"babel jsx尖括号"}})]),t._v(" "),e("p",[t._v("babel不支持ts这些特性，那是否可以用babel编译ts呢？")]),t._v(" "),e("h2",{attrs:{id:"babel还是tsc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel还是tsc"}},[t._v("#")]),t._v(" babel还是tsc？")]),t._v(" "),e("p",[t._v("babel 不支持const enum(会作为enum处理)，不支持namespace的跨文件合并，导出非const得值，不支持过时的export = import = 的模块语法")]),t._v(" "),e("p",[t._v("其实这些影响不大，只要代码里没用到这些语法，完全可以用babel来编译ts")]),t._v(" "),e("p",[e("span",{staticStyle:{color:"blue"}},[t._v("babel编译ts代码的优点是可以通过插件支持更多的语法特性,而且生成的代码是按照targets的配置按需引入core-js的，而tsc没有这方面的处理，只能全量引入")])]),t._v(" "),e("p",[t._v("而且tsc因为要做类型检查所以比较慢的，而babel不做类型检查，编译会快很多。")]),t._v(" "),e("p",[t._v("那用babel编译，就不做类型检查了吗？")]),t._v(" "),e("p",[t._v("可以用tsc-noEmit来做类型检查，加上noEmit选项就不会生成代码了")]),t._v(" "),e("p",[t._v("如果你要生成d.ts，也要单独跑下tsc编译")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("babel和tsc的编译流程大同小异，都是把源码转换成AST的Parser,都会做语义分析(作用域分析)和AST的transform，最后都会用Generator(或者Emitter)把AST打印成目标代码并生成sourcemap")]),t._v(" "),e("p",[e("span",{staticStyle:{color:"red"}},[t._v("但是babel不做类型检查，也不会生d.ts")])]),t._v(" "),e("p",[e("span",{staticStyle:{color:"red"}},[t._v("tsc支持最新的es标准特性和部分草案的特性(比如decorator)，而babel通过@babel/preset-env支持所有标准特性。也可以通过@babel/proposal-xx来支持各种非标准特性，支持的语言特性上babel更强一些。")])]),t._v(" "),e("p",[e("span",{staticStyle:{color:"red"}},[t._v("tsc没有做polyfill的处理，需要全量引入core-js，而babel的@babel/preset-env会根据targets的配置来按需引入core-js,引入方式受useBuiltIns影响(entry是在入口引入targets需要的，usage是每个模块引入用到的)")])]),t._v(" "),e("p",[e("span",{staticStyle:{color:"red"}},[t._v("但是babel因为是每个文件单独编译(tsc是整个项目一起编译)，而且也不解析类型，所以 const enum，namespace 合并，namespace 导出非 const 值并不支持。而且过时的 export =  的模块语法也不支持。")])]),t._v(" "),e("p",[t._v("但这些影响不大，完全可以用 babel 编译 ts 代码来生成体积更小的代码，不做类型检查编译速度也更快。")]),t._v(" "),e("p",[t._v("如果想做类型检查可以单独执行 tsc --noEmit。")]),t._v(" "),e("p",[t._v("当然，文中只是讨论了 tsc 和 babel 编译 ts 代码的区别，并没有说最好用什么，具体用什么编译 ts，大家可以根据场景自己选择。")]),t._v(" "),e("h2",{attrs:{id:"资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/uSwgwCMahgeMKq1tiIYOww",target:"_blank",rel:"noopener noreferrer"}},[t._v("编译ts代码用tsc还是babel"),e("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);