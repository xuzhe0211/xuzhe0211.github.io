(window.webpackJsonp=window.webpackJsonp||[]).push([[412],{2207:function(e,t,n){"use strict";n.r(t);var r=n(46),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[e._v("#")]),e._v(" 描述")]),e._v(" "),n("p",[e._v("koa处理post请求的时，需要对body传递过来的数据进行处理")]),e._v(" "),n("p",[e._v("实际上如果要手动实现一个能够处理application/x-www-urlencoded的中间件，还得借助原生node.js进行处理，")]),e._v(" "),n("p",[e._v("koa封装了原生node.js的request对象到ctx.req中")]),e._v(" "),n("p",[e._v("而借助原生node.js的request对象，监听data事件以及end事件，进行处理")]),e._v(" "),n("blockquote",[n("p",[e._v("koa-bodyparser post请求body解析的中间件；bodyparser可以解析普通的表单（application/x-www-form-urlencoded），没办法解析文件（Content-Type:multipart/form-data）")])]),e._v(" "),n("h2",{attrs:{id:"前置知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前置知识"}},[e._v("#")]),e._v(" 前置知识")]),e._v(" "),n("p",[e._v("在理解koa-bodyparser原理之前，首先需要了解部分HTTP相关知识")]),e._v(" "),n("h3",{attrs:{id:"报文主体"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#报文主体"}},[e._v("#")]),e._v(" 报文主体")]),e._v(" "),n("p",[e._v("HTTP报文主要分为请求报文和响应报文,koa-bodyparser主要针对请求报文的处理")]),e._v(" "),n("p",[e._v("请求报文主要由以下三个部分组成")]),e._v(" "),n("ul",[n("li",[e._v("报文头部")]),e._v(" "),n("li",[e._v("空行")]),e._v(" "),n("li",[e._v("报文主体")])]),e._v(" "),n("p",[e._v("而koa-bodyparser中的body指的就是请求报文中的报文主体部分。")]),e._v(" "),n("h3",{attrs:{id:"服务器端获取报文主体流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#服务器端获取报文主体流程"}},[e._v("#")]),e._v(" 服务器端获取报文主体流程")]),e._v(" "),n("p",[e._v("HTTP底层采用TCP提供可靠的字节流服务,简单而言就是报头主体部分会被转换成二进制数据在网络中传输，所以服务器端首先需要拿到二进制流数据。")]),e._v(" "),n("p",[e._v("谈到网络传输，当然会涉及到传输速度的优化，而其中一种优化方式就是对内容进行压缩编码，常用的压缩编码方式有")]),e._v(" "),n("ul",[n("li",[e._v("gzip")]),e._v(" "),n("li",[e._v("compress")]),e._v(" "),n("li",[e._v("deflate")]),e._v(" "),n("li",[e._v("identity(不执行压缩或不会变化的默认编码格式)")])]),e._v(" "),n("p",[e._v("服务器端会根据报文头部信息中的Content-Encoding确认采用何种编码规范")]),e._v(" "),n("p",[e._v("接下来就需要将二进制数据转换为相应的字符，而字符也有不同的字符编码方式，例如对于中文字符处理差异巨大的UTF-8和GBK,UTF-8编码汉字通常需要三个字节，而GBK只需要两个字节。所以还需要在请求报文的头部信息中设置Content-Type使用的字符编码信息(默认情况下采用的是UTF-8),这样服务器端就可以利用响应的字符规则进行编码，得到正确的字符串。")]),e._v(" "),n("p",[e._v("拿到字符串之后，服务器又要问了:客户端，这一段字符串是啥意思啊？")]),e._v(" "),n("p",[e._v("根据不同的应用场景，客户端会对字符串采用不同的编码方式，长江的编码方式有")]),e._v(" "),n("ul",[n("li",[e._v("URL编码方式：a= 1 &b =1;")]),e._v(" "),n("li",[e._v("JSON编码方式: {a: 1, b: 2}")])]),e._v(" "),n("p",[e._v("客户端会将采用的字符串编码方式设置在请求报文头部信息的Content-Type属性中，这样服务器端根据相应的字符串编码规则进行解码，就能够明白客户端所传递的信息了。")]),e._v(" "),n("p",[e._v("下面一步步分析koa-bodyparser是如何处理这一系列操作的，从而得到报文主体的内容。")]),e._v(" "),n("h2",{attrs:{id:"获取二进制数据流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#获取二进制数据流"}},[e._v("#")]),e._v(" 获取二进制数据流")]),e._v(" "),n("p",[e._v("NodeJS中获取请求报文主体二进制数据流主要通过监听request对象的data事件完成。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 示例一\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  const body = [];\n\n  req.on('data', chunk => {\n    body.push(chunk);\n  })\n\n  req.on('end', () => {\n    const chunks = Buffer.concat(body); // 接收到的二进制数据流\n\n    // 利用res.end进行相应处理\n    res.end(chunks.toString())\n  })\n}).listen(1234)\n")])])]),n("p",[e._v("而koa-bodyparser主要是对"),n("a",{attrs:{href:"https://github.com/cojs/co-body",target:"_blank",rel:"noopener noreferrer"}},[e._v("co-body"),n("OutboundLink")],1),e._v("的封装,而【co-body】中主要采用"),n("a",{attrs:{href:"https://github.com/stream-utils/raw-body",target:"_blank",rel:"noopener noreferrer"}},[e._v("raw-body"),n("OutboundLink")],1),e._v("模块获取请求报文主体的二进制数据流，【raw-body】主要是对上述示例代码的封装和健壮性处理。")]),e._v(" "),n("h2",{attrs:{id:"内容解码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内容解码"}},[e._v("#")]),e._v(" 内容解码")]),e._v(" "),n("p",[e._v("客户端会将内容编码的方式放入请求报文头部信息Content-Encoding属性中,服务器端接受报文主体的二进制数据时,会根据该头部信息进行解压操作，当然服务器端可以在响应报文头部信息Accept-Encoding属性中添加支持的解压方式")]),e._v(" "),n("p",[e._v("而【raw-body】主要采用"),n("a",{attrs:{href:"https://github.com/stream-utils/inflation",target:"_blank",rel:"noopener noreferrer"}},[e._v("inflation"),n("OutboundLink")],1),e._v("模块进行解压处理")]),e._v(" "),n("h2",{attrs:{id:"字符解码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#字符解码"}},[e._v("#")]),e._v(" 字符解码")]),e._v(" "),n("p",[e._v("一般而言，UTF-8是互联网中主流的字符编码方式，前面也提到了还有GBK编码方式，相比较UTF-8，它编码中文只需要2个字节，那么在字符编码时误用UTF-8编码GKB编码字符，就会出现中文乱码问题。")]),e._v(" "),n("p",[e._v("NodeJS主要通过Buffer处理二进制数据流，但是它并不支持GBK字符编码方式，需要通过"),n("a",{attrs:{href:"https://github.com/ashtuchkin/iconv-lite",target:"_blank",rel:"noopener noreferrer"}},[e._v("iconv-lite"),n("OutboundLink")],1),e._v("模块进行处理")]),e._v(" "),n("p",[n("strong",[e._v("示例一")]),e._v("中的代码就存在没有正确处理字符编码的问题,那么报文主体中的字符采用GBK编码方式，必然会出现中文乱码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const request = require('request');\nconst iconv = require('iconv-lite');\n\nrequest.post({\n  url: 'http://localhost:1234/',\n  body: iconv.encode('中文', 'GBK'),\n  headers: {\n    'Content-Type': 'text/plain;charset=GBK'\n  }\n}, (error, response, body) => {\n  console.log(body); // 发生中文乱码情况\n})\n")])])]),n("p",[e._v("NodeJS中的Buffer默认采用UTF-8字符编码方式，这里借助【iconv-lite】模块处理不同的字符编码方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const chunks = Buffer.concat(body);\nres.end(iconv.decode(chunks, charset)); // charset通过Content-Type得到\n")])])]),n("h2",{attrs:{id:"字符串解码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#字符串解码"}},[e._v("#")]),e._v(" 字符串解码")]),e._v(" "),n("p",[e._v("前面已经提到了字符串的二种编码方式，他们对应的Content-Type分别为：")]),e._v(" "),n("ul",[n("li",[e._v("URL编码application/x-www-form-urlencoded")]),e._v(" "),n("li",[e._v("JSON编码 application/json")])]),e._v(" "),n("p",[e._v("对于前端来说，URL编码并不默认，经常会用到URL拼接操作，唯一需要注意的是不要忘记对键值对进行decodeURIComponent()处理")]),e._v(" "),n("p",[e._v("当客户端发送请求主体时，需要进行编码操作")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("'a=1&b=2&c=3'\n")])])]),n("p",[e._v("服务器端在根据URL编码规则解码，得到响应的对象。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// URL编码方式 简单的解码方法实现\nfunction decode(qs, sep = '&', eq = '=') {\n  const obj = {};\n  qs = qs.split(step);\n\n  for (let i = 0, max = qs.length; i < max; i++) {\n    const item = qs[i];\n    const index = item.indexOf(eq);\n\n    let key, value = item.\n\n    if (~index) {\n      key = item.substr(0, index);\n      value = item.substr(index + 1);\n    } else {\n      key = item;\n      value = ''\n    }\n    key = decodeURIComponent(key);\n    value = decodeURIComponent(value);\n\n    if (!obj.hasOwnProperty(key)) {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nconsole.log(decode('a=1&b=2&c=3')) // {a: '1', b: '2', c: '3'}\n")])])]),n("p",[e._v("URL编码方式是和处理简单的键值对数据，并且很多框架的Ajax中的Content-Type默认值都是它，但是对于复杂的嵌套对象就不太好处理了，这时就需要JSON编码方式大显身手了。")]),e._v(" "),n("p",[e._v("客户端发送请求主体时，只需要采用JSON.stringify进行编码。服务器端只要采用JSON.parse进行解码即可")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const strictJSONReg = /^[\\x20\\x09\\x0a\\x0d]*(\\[|\\{)/;\nfunction parse(str) {\n  if (!strict) return str ? JSON.parse(str) : str;\n  // 严格模式下，总是返回一个对象\n  if (!str) return {};\n  // 是否为合法的JSON字符串\n  if (!strictJSONReg.test(str)) {\n    throw new Error('invalid JSON, only supports object and array');\n  }\n  return JSON.parse(str);\n}\n")])])]),n("p",[e._v("除了上述两种字符串编码方式，koa-bodyparser还支持不采用任何字符串编码方式的普通字符串")]),e._v(" "),n("p",[e._v("三种字符串编码处理由【co-body】模块提供，koa-bodyparser中通过判断Content-Type类型，调用不同的处理方式，将获取到的结果挂载在ctx.request.body")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("return async function bodyParser(ctx, next) {\n  if(ctx.request.body !== undefined) return await next();\n  if (ctx.disableBodyParser) return await next();\n  try {\n    // 最重要的异步，将解析的内容挂在到koa的上下文中\n    const res = await parseBody(ctx);\n    ctx.request.body = 'parsed' in res ? res.parsed : {};\n    if (ctx.request.rawBody === undefined) ctx.request.rawBody = res.raw; // 保存原始字符串\n  } catch (err) {\n    if (onerror) {\n      onerror(err, ctx);\n    } else {\n      throw err;\n    }\n  }\n  await next();\n}\n\nasync function parseBody(ctx) {\n    if (enableJson && ((detectJSON && detectJSON(ctx)) || ctx.request.is(jsonTypes))) {\n      return await parse.json(ctx, jsonOpts); // application/json等json type\n    }\n    if (enableForm && ctx.request.is(formTypes)) {\n      return await parse.form(ctx, formOpts); // application/x-www-form-urlencoded\n    }\n    if (enableText && ctx.request.is(textTypes)) {\n      return await parse.text(ctx, textOpts) || ''; // text/plain\n    }\n    return {};\n}\n")])])]),n("p",[e._v("其实还有一种比较常见的Content-type, 当采用表单上传时，报文主体中会包含多个实体主体：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('------WebKitFormBoundaryqsAGMB6Us6F7s3SF\nContent-Disposition: form-data; name="image"; filename="image.png"\nContent-Type: image/png\n\n\n------WebKitFormBoundaryqsAGMB6Us6F7s3SF\nContent-Disposition: form-data; name="text"\n\n------WebKitFormBoundaryqsAGMB6Us6F7s3SF--\n')])])]),n("p",[e._v("这种方式处理相对比较复杂，koa-bodyparser中并没有提供该Content-Type的解析。（下一篇中应该会介绍_）")]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("以上便是koa-bodyparser的核心实现原理，其中涉及到很多关于HTTP的基础知识，对于HTTP不太熟悉的同学，可以推荐看【图解HTTP】")]),e._v(" "),n("h2",{attrs:{id:"资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[e._v("#")]),e._v(" 资料")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.imooc.com/article/274059",target:"_blank",rel:"noopener noreferrer"}},[e._v("玩转Koa-koa-bodyparser原理解析"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);