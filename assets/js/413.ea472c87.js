(window.webpackJsonp=window.webpackJsonp||[]).push([[413],{2208:function(a,t,e){"use strict";e.r(t);var r=e(46),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("p",[a._v("Koa为了保持自身的简洁，并没有捆绑中间件。但是在实际的开发中，我们需要和形形色色的中间件打交道，本文将要分析的是经常用到的路由中间件--koa-router.")]),a._v(" "),e("h2",{attrs:{id:"koa-router概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#koa-router概述"}},[a._v("#")]),a._v(" koa-router概述")]),a._v(" "),e("p",[a._v("koa-router的源码只有两个文件：router.js和layer.js，分别对应Router对象和Layer对象。")]),a._v(" "),e("p",[a._v("Layer对象是对单个路由的管理,其中包含的信息有路由路径(path)、路由请求方法(method)和路由执行函数(middleware),并且提供路由的验证以及params参数解析的方法。")]),a._v(" "),e("p",[a._v("相比较Layer对象，Router对象则是在对所有注册路由的统一处理，并且它的API是面向开发者的。")]),a._v(" "),e("p",[a._v("接下来从以下几个方面全面解析koa-router的实现原理")]),a._v(" "),e("ul",[e("li",[a._v("Layer对象的实现")]),a._v(" "),e("li",[a._v("路路由注册")]),a._v(" "),e("li",[a._v("路由匹配")]),a._v(" "),e("li",[a._v("路由执行流程")])]),a._v(" "),e("h2",{attrs:{id:"layer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#layer"}},[a._v("#")]),a._v(" Layer")]),a._v(" "),e("p",[a._v("Layer对象主要是对单个路由的管理，是整个koa-router中最小的处理单元，后续模块的处理都离不开Layer中的方法，这正是首先介绍Layer的重要原因")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  // 支持路由别名\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  // 将路由执行函数保存在stack中，支持输入多个处理函数\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  methods.forEach(function(method) {\n    var l = this.methods.push(method.toUpperCase());\n    // Head请求头部信息与GET一致，这里就一起处理了\n    if(this.methods[l - 1] === \'GET\') {\n      this.methods.unshift(\'HEAD\')\n    }\n  }, this)\n\n  // 确保类型正确\n  this.stack.forEach(function(fn) {\n    var type = (typeof fn);\n    if (type !== \'function\') {\n       throw new Error(\n        methods.toString() + " `" + (this.opts.name || path) +"`: `middleware` "\n        + "must be a function, not `" + type + "`"\n      );\n    }\n  }, this)\n\n  this.path = path;\n  // 1. 根据路由路径生成路由正则表达式\n  // 2. 将params参数信息保存在paramsNames数组中\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n}\n')])])]),e("p",[a._v("Layer构造函数主要用来初始化路由路径、路由请求方法数组、路由处理函数数组、路由正则表达式以及params参数信息数组，其中主要采用"),e("a",{attrs:{href:"https://github.com/pillarjs/path-to-regexp",target:"_blank",rel:"noopener noreferrer"}},[a._v("path-to-regexp"),e("OutboundLink")],1),a._v("方法根据路径字符串生成正则表达式，通过改正则表达式，可以事先路由匹配以及params参数的捕获。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 验证路由\nLayer.prototype.match = function(path) {\n  return this.regexp.test(path);\n}\n\n// 捕获params参数\nLayer.prototype.captures = function(path) {\n  // 后续会提到 对于路由级别中间件，无需捕获params\n  if(this.opts.ignoreCaptures) return [];\n  return path.match(this.regexp).slice(1);\n}\n")])])]),e("p",[a._v("根据paramsNames中的参数信息以及captrues方法，可以获取到当前路由params参数的键值对")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Layer.prototype.params = funciton(path, captures, existingParams) {\n  var params = existingParams || {};\n  for (var len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      var c = captures[i];\n      params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n  return params;\n}\n")])])]),e("p",[a._v("需要注意上述代码中的safeDecodeURIComponent方法，为了避免服务器收到不可预知的请求，对于任何用户输入的作为URI部分的内容都需要采用encodeURIComponent进行转义，否则当用户输入的内容中含有'&'、'='、'?'等字符时，会出现预料之外的情况。而当我们获取URL上的参数时，则需要通过decodeURIComponent进行解码，而decodeURIComponent进行解码，而decodeURLComponent只能解码有encodeURIComponent方法或者类似方法解码，如果编码方法不符合要求，decodeURIComponent则会抛出异常URIError，所以作者在这里对该方法进行了安全处理")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    // 编码方式不符合要求，返回原字符串\n    return text;\n  }\n}\n")])])]),e("p",[a._v("Layer还提供了对于单个params前置处理的方法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Layer.prototype.param = function(param, fn) {\n  var stack = this.stack;\n  var params = this.paramNames;\n  var middleware = function(ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  }\n  middleware.param = param;\n  var names = params.map(function(p) {\n    return p.name;\n  })\n  var x = names.indexOf(param);\n  if (x > -1) {\n    stack.some(function (fn, i) {\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // 将单个param前置处理函数插入正确的位置\n        stack.splice(i, 0, middleware);\n        return true; // 跳出循环\n      }\n    });\n  }\n\n  return this;\n}\n")])])]),e("p",[a._v("上述代码中通过some方法寻找单个param处理函数的原因在于以下两点")]),a._v(" "),e("ul",[e("li",[a._v("保持param处理函数位于其他路由处理函数的前面")]),a._v(" "),e("li",[a._v("路由中存在多个param参数，需保持param处理函数的先后顺序")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Layer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = prefix + this.path; // 拼接新的路由路径\n    this.paramNames = [];\n    // 根据新的路由路径字符串生成正则表达式\n    this.regexp = pathToRegExp(this.path, this.paramNames, this.opts);\n  }\n  return this;\n};\n")])])]),e("p",[a._v("Layer中的setPrefix方法用于设置路由路径的前缀，这在嵌套路由的实现中尤其重要。")]),a._v(" "),e("p",[a._v("最后，Layer还提供了根据路由生成url的方法，主要采用path-to-regexp的compile和parse对路由路径中的param进行替换，而在拼接query的环节，正如前面所说需要对键值对进行繁琐的encodeURIComponent操作，作者采用了urijs提供的简洁api进行处理。")]),a._v(" "),e("h2",{attrs:{id:"路由注册"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由注册"}},[a._v("#")]),a._v(" 路由注册")]),a._v(" "),e("h2",{attrs:{id:"资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[a._v("#")]),a._v(" 资料")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.imooc.com/article/274032",target:"_blank",rel:"noopener noreferrer"}},[a._v("玩转Koa -- koa-router原理解析"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);