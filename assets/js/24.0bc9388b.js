(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{2267:function(t,a,v){"use strict";v.r(a);var _=v(46),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[_("img",{attrs:{src:v(704),alt:"高级数据结构"}})]),t._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),_("ul",[_("li",[_("span",{staticStyle:{color:"blue"}},[t._v("优先队列")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"blue"}},[t._v("图")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"blue"}},[t._v("前缀树")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"blue"}},[t._v("线段树")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"blue"}},[t._v("树状数组")])])]),t._v(" "),_("h2",{attrs:{id:"优先队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优先队列"}},[t._v("#")]),t._v(" 优先队列")]),t._v(" "),_("h3",{attrs:{id:"与普通队列的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与普通队列的区别"}},[t._v("#")]),t._v(" 与普通队列的区别")]),t._v(" "),_("ul",[_("li",[t._v("保证每次取出的元素是队列中优先级最高的")]),t._v(" "),_("li",[t._v("优先级别可自定义")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(705),alt:"优先队列"}})]),t._v(" "),_("h3",{attrs:{id:"常用的场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用的场景"}},[t._v("#")]),t._v(" 常用的场景")]),t._v(" "),_("ul",[_("li",[t._v("从杂乱无章的数据中按照一定的顺序(或者优先级)刷选数据")])]),t._v(" "),_("h3",{attrs:{id:"本质"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本质"}},[t._v("#")]),t._v(" 本质")]),t._v(" "),_("p",[t._v("二叉堆结构，堆在英文里叫Binary Heap")]),t._v(" "),_("p",[t._v("利用一个数组结构来实现完全二叉树")]),t._v(" "),_("h3",{attrs:{id:"特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),_("p",[t._v("数组里的每一个元素array[0]拥有最高的优先级，给定一个下标i，那么对于元素array[i]而言")]),t._v(" "),_("ul",[_("li",[t._v("父节点对应的下标是(i - 1) / 2;")]),t._v(" "),_("li",[t._v("右侧子节点对应的元素下标是2 * i+ 1；")]),t._v(" "),_("li",[t._v("左侧对应的元素的下标是 2* i + 2;\n数组中每个元素的优先级都必须要高于两侧的子节点")])]),t._v(" "),_("h3",{attrs:{id:"其基本操作为一下两个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其基本操作为一下两个"}},[t._v("#")]),t._v(" 其基本操作为一下两个")]),t._v(" "),_("ul",[_("li",[t._v("向上筛选--新增节点放在最后，沿着节点向上爬")]),t._v(" "),_("li",[t._v("向下筛选- 不断执行向下筛选的操作，该元素和它的两个孩子节点对比，发现那个优先级别最高，如果孩子节点级别高，然后直接交换；沿着树的高度往下爬")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(706),alt:"堆"}})]),t._v(" "),_("p",[t._v("** 另一个重要的时间复杂度：优先队列初始化(O^n)**")]),t._v(" "),_("h3",{attrs:{id:"前k个高频元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前k个高频元素"}},[t._v("#")]),t._v(" 前K个高频元素")]),t._v(" "),_("p",[_("img",{attrs:{src:v(707),alt:"前K个高频元素"}})]),t._v(" "),_("h2",{attrs:{id:"图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[t._v("#")]),t._v(" 图")]),t._v(" "),_("p",[t._v("最基本的知识点如下")]),t._v(" "),_("ul",[_("li",[t._v("阶、度(出度，入度)")]),t._v(" "),_("li",[t._v("树、森林、环")]),t._v(" "),_("li",[t._v("有向图、无向图、完全有向图、完全无向图")]),t._v(" "),_("li",[t._v("连通图、连通分量")]),t._v(" "),_("li",[t._v("图的存储和表达方式:邻接矩阵、邻接链表")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("ul",[_("li",[t._v("度: 某个定点的度就是依附于该定点的变得个数")]),t._v(" "),_("li",[t._v("环：是一条至少含有一条边且终点和起点相同的路径")]),t._v(" "),_("li",[t._v("路径:是由边顺序连接的一系列的顶点组成")]),t._v(" "),_("li",[t._v("子图：是一幅图的所有边的子集(包含这些边依附的顶点)组成的图")]),t._v(" "),_("li",[t._v("相邻定点:当两个定点通过一条边相连时，我们称这两个定点是相邻的，并且称这条边依附于这两个顶点")])])]),t._v(" "),_("p",[t._v("围绕图的算法也是各式各样")]),t._v(" "),_("ul",[_("li",[t._v("图的遍历：深度优先、广度优先")]),t._v(" "),_("li",[t._v("环的检测：有向图、无向图")]),t._v(" "),_("li",[t._v("拓扑排序")]),t._v(" "),_("li",[t._v("最短路径算法")]),t._v(" "),_("li",[t._v("连通性相关算法： Kosarauju、Tarjan、求解孤岛的数量、判断是否为树")]),t._v(" "),_("li",[t._v("图的着色、旅行商问题等")])]),t._v(" "),_("p",[t._v("必须熟练掌握的知识点")]),t._v(" "),_("ul",[_("li",[_("span",{staticStyle:{color:"red"}},[t._v("图的存储和表达方式：邻接矩阵、邻接链表")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"red"}},[t._v("图的遍历：深度优先、广度优先")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"red"}},[t._v("二部图的检测、树的检测、环的检测：有向图、无向图")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"red"}},[t._v("拓扑排序")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"red"}},[t._v("联合-查找算法")])]),t._v(" "),_("li",[_("span",{staticStyle:{color:"red"}},[t._v("最短路径")])])]),t._v(" "),_("h3",{attrs:{id:"图的存储结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图的存储结构"}},[t._v("#")]),t._v(" 图的存储结构")]),t._v(" "),_("p",[t._v("要表示一幅图，只需要表示清楚一下两个部分内容即可")]),t._v(" "),_("ul",[_("li",[t._v("图中所有的顶点")]),t._v(" "),_("li",[t._v("所有连接顶点的边")])]),t._v(" "),_("p",[_("span",{staticStyle:{color:"red"}},[t._v("常见的图的存储结构有两种:邻接矩阵和邻接表")])]),t._v(" "),_("h4",{attrs:{id:"邻接矩阵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#邻接矩阵"}},[t._v("#")]),t._v(" 邻接矩阵")]),t._v(" "),_("p",[t._v("二维数组---二维数组索引表示顶点，二维数组的值表示边")]),t._v(" "),_("p",[t._v("缺点-- 占用内容空间是n^2，如果我们处理的问题规模比较大的话 内存空间可能不够用")]),t._v(" "),_("h4",{attrs:{id:"邻接表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#邻接表"}},[t._v("#")]),t._v(" 邻接表")]),t._v(" "),_("p",[t._v("数组--数组的每个值存储的是队列对象(queue对象)； 数组索引表示图的顶点 值表示与索引相邻的顶点")]),t._v(" "),_("p",[t._v("邻接表的空间并不是线性级别的 性能好于邻接矩阵")]),t._v(" "),_("h3",{attrs:{id:"判断二分图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#判断二分图"}},[t._v("#")]),t._v(" 判断二分图")]),t._v(" "),_("p",[_("img",{attrs:{src:v(708),alt:"二分图"}})]),t._v(" "),_("h2",{attrs:{id:"前缀树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前缀树"}},[t._v("#")]),t._v(" 前缀树")]),t._v(" "),_("p",[_("strong",[t._v("也称字典树")])]),t._v(" "),_("p",[t._v("这种数据结构被广泛地运用在字典查询当中")]),t._v(" "),_("p",[_("strong",[t._v("什么是字典查找？")])]),t._v(" "),_("p",[t._v("例如：给定一系列构成字典的字符串，要求在字典当中找出所有以『ABC』开头的字符串")]),t._v(" "),_("ul",[_("li",[t._v("暴露搜索法 --- O(M * n)")]),t._v(" "),_("li",[t._v("前缀树--O(m)")])]),t._v(" "),_("h3",{attrs:{id:"经典应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#经典应用"}},[t._v("#")]),t._v(" 经典应用")]),t._v(" "),_("p",[t._v("搜索框输入搜索文字，会罗列以搜索词开头的相关搜索")]),t._v(" "),_("p",[t._v("汉字拼音输入法")]),t._v(" "),_("h3",{attrs:{id:"重要性质"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重要性质"}},[t._v("#")]),t._v(" 重要性质")]),t._v(" "),_("p",[t._v("每个节点至少包含两个基本属性")]),t._v(" "),_("ul",[_("li",[t._v("children：数组或者集合，罗列出每个分支当中包含的所有字符")]),t._v(" "),_("li",[t._v("isEnd：布尔值，表示该节点是否为某字符串的几位")])]),t._v(" "),_("p",[t._v("根节点是空的--只利用节点的children属性")]),t._v(" "),_("p",[t._v("除了根节点，其他所有节点都可能是单词的结尾，叶子节点一定都是单词的结尾")]),t._v(" "),_("h3",{attrs:{id:"基本操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[t._v("#")]),t._v(" 基本操作")]),t._v(" "),_("ol",[_("li",[t._v("创建")])]),t._v(" "),_("p",[_("strong",[t._v("方法")])]),t._v(" "),_("p",[t._v("遍历一遍输入的字符串，对每个字符串的字符进行遍历")]),t._v(" "),_("p",[t._v("从前缀树的根节点开始，将每个字符加入到节点的childrend字符集当中")]),t._v(" "),_("p",[t._v("如果字符集已经包含了这个字符，跳过")]),t._v(" "),_("p",[t._v("如果当前字符是字符串的最后一个，把当前节点的isEnd标记为真")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("搜索")])]),t._v(" "),_("p",[t._v("从前缀树的根节点触发，逐个匹配输入的前缀字符")]),t._v(" "),_("p",[t._v("如果遇到了，继续下一层搜索")]),t._v(" "),_("h3",{attrs:{id:"单词搜索贰"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单词搜索贰"}},[t._v("#")]),t._v(" 单词搜索贰")]),t._v(" "),_("p",[_("img",{attrs:{src:v(709),alt:"单词搜索"}}),t._v(" "),_("img",{attrs:{src:v(710),alt:"单词搜索"}})]),t._v(" "),_("h2",{attrs:{id:"线段树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线段树"}},[t._v("#")]),t._v(" 线段树")]),t._v(" "),_("h3",{attrs:{id:"一个例题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个例题"}},[t._v("#")]),t._v(" 一个例题")]),t._v(" "),_("p",[t._v("假设我们有一个数组array[0...n - 1],里面有n个元素，现在我们要经常对这个数组做两个事")]),t._v(" "),_("ol",[_("li",[t._v("更新数组元素的数值")]),t._v(" "),_("li",[t._v("求数组任意一段去区间里元素的总和(或者平均值)")])]),t._v(" "),_("ul",[_("li",[t._v("方法一：遍历一遍数组 (O(n))")]),t._v(" "),_("li",[t._v("线段树(O(logn))")])]),t._v(" "),_("h3",{attrs:{id:"什么是线段树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是线段树"}},[t._v("#")]),t._v(" 什么是线段树")]),t._v(" "),_("p",[_("img",{attrs:{src:v(711),alt:"线段树"}})]),t._v(" "),_("h3",{attrs:{id:"计算右侧小宇当前元素的个数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算右侧小宇当前元素的个数"}},[t._v("#")]),t._v(" 计算右侧小宇当前元素的个数")]),t._v(" "),_("p",[_("img",{attrs:{src:v(712),alt:"计算右侧小于当前元素的个数"}})]),t._v(" "),_("p",[t._v("判断在那个区间，对应区间+1\n"),_("img",{attrs:{src:v(713),alt:"步骤1"}}),t._v(" "),_("img",{attrs:{src:v(714),alt:"步骤1"}}),t._v(" "),_("img",{attrs:{src:v(715),alt:"步骤1"}}),t._v(" "),_("img",{attrs:{src:v(347),alt:"步骤1"}})]),t._v(" "),_("h2",{attrs:{id:"树状数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#树状数组"}},[t._v("#")]),t._v(" 树状数组")]),t._v(" "),_("h3",{attrs:{id:"一个例题-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个例题-2"}},[t._v("#")]),t._v(" 一个例题")]),t._v(" "),_("p",[t._v("假设我们有一个数组array[0...n -1],里面有n个元素，我们要经常对这个数组做两件事")]),t._v(" "),_("ol",[_("li",[t._v("更新数组元素的数组")]),t._v(" "),_("li",[t._v("求数组前K个元素总和(或平均值)")])]),t._v(" "),_("ul",[_("li",[t._v("线段树(Ologn)")]),t._v(" "),_("li",[t._v("树状数组（Ologn）")])]),t._v(" "),_("h3",{attrs:{id:"重要的基本特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重要的基本特征"}},[t._v("#")]),t._v(" 重要的基本特征")]),t._v(" "),_("p",[t._v("利用数组来表述多叉树的结构，和优先队列有些类似")]),t._v(" "),_("p",[t._v("优先队列是用数组来表示完全二叉树，而树状数组是多叉树")]),t._v(" "),_("p",[t._v("树状数组的第一个元素是空节点")]),t._v(" "),_("p",[t._v("如果节点tree[k]是tree[x]的父节点，那么需要满足y= x - (x & (-x))")]),t._v(" "),_("h2",{attrs:{id:"结束"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结束"}},[t._v("#")]),t._v(" 结束")]),t._v(" "),_("p",[_("img",{attrs:{src:v(347),alt:"步骤1"}})])])}),[],!1,null,null,null);a.default=s.exports},347:function(t,a,v){t.exports=v.p+"assets/img/47.ccb17b93.jpg"},704:function(t,a,v){t.exports=v.p+"assets/img/35.cb9eb82b.jpg"},705:function(t,a,v){t.exports=v.p+"assets/img/36.24f66339.jpg"},706:function(t,a,v){t.exports=v.p+"assets/img/37.433c49ab.jpg"},707:function(t,a,v){t.exports=v.p+"assets/img/38.28ac8177.jpg"},708:function(t,a,v){t.exports=v.p+"assets/img/39.6c530184.jpg"},709:function(t,a,v){t.exports=v.p+"assets/img/40.c0078ae7.jpg"},710:function(t,a,v){t.exports=v.p+"assets/img/41.d75fe06b.jpg"},711:function(t,a,v){t.exports=v.p+"assets/img/42.fdaff0b8.jpg"},712:function(t,a,v){t.exports=v.p+"assets/img/43.0dd3bf7e.jpg"},713:function(t,a,v){t.exports=v.p+"assets/img/44.fe9c4696.jpg"},714:function(t,a,v){t.exports=v.p+"assets/img/45.1e555161.jpg"},715:function(t,a,v){t.exports=v.p+"assets/img/46.deb4f212.jpg"}}]);