(window.webpackJsonp=window.webpackJsonp||[]).push([[366],{1941:function(t,e,s){t.exports=s.p+"assets/img/16c5026d4181224c_tplv-t2oaga2asx-watermark.4a73541b.png"},2855:function(t,e,s){"use strict";s.r(e);var n=s(46),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"为什么要用nuxt-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用nuxt-js"}},[t._v("#")]),t._v(" 为什么要用Nuxt.js")]),t._v(" "),n("p",[t._v("原因其实不用多说，就是利用Nuxt.js的服务端渲染能力来解决Vue项目的SEO问题")]),t._v(" "),n("h2",{attrs:{id:"nuxt-js和纯vue项目的简单对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nuxt-js和纯vue项目的简单对比"}},[t._v("#")]),t._v(" Nuxt.js和纯Vue项目的简单对比")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("build后目标产物不同")]),t._v(" "),n("p",[t._v("vue:dist")]),t._v(" "),n("p",[t._v("nuxt:.nuxt")])]),t._v(" "),n("li",[n("p",[t._v("网页渲染流程")]),t._v(" "),n("p",[t._v("vue: 客户端渲染，先下载js后，通过ajax来渲染页面")]),t._v(" "),n("p",[t._v("nuxt:服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以做到无需发起ajax请求")])]),t._v(" "),n("li",[n("p",[t._v("部署流程")]),t._v(" "),n("p",[t._v("vue：只需部署dist目录到服务器，没有服务端，需要用nginx等做web服务器；")]),t._v(" "),n("p",[t._v("nuxt: 需要部署几乎所有文件到服务器(除node_modules, .git),自带服务端，需要pm2管理(部署时需要reload pm2)，若要求用域名，则需要nginx做代理")])]),t._v(" "),n("li",[n("p",[t._v("项目入口")])])]),t._v(" "),n("p",[t._v("vue: /src/main.js，在main.js可以做一些全局注册的初始化工作")]),t._v(" "),n("p",[t._v("nuxt:没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置执行")]),t._v(" "),n("h2",{attrs:{id:"从零搭建一个nuxt-js项目并配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#从零搭建一个nuxt-js项目并配置"}},[t._v("#")]),t._v(" 从零搭建一个nuxt.js项目并配置")]),t._v(" "),n("h3",{attrs:{id:"新建项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新建项目"}},[t._v("#")]),t._v(" 新建项目")]),t._v(" "),n("p",[t._v("直接使用脚手架进行安装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npx create-nuxt-app <项目名>\n")])])]),n("p",[n("img",{attrs:{src:s(1941),alt:"脚手架初始化项目"}})]),t._v(" "),n("p",[t._v("大概选上面这些选项")]),t._v(" "),n("p",[t._v("值得一说的是，关于"),n("strong",[t._v("Choose custom server framework(选择服务端框架)")]),t._v("，可以根据你的业务情况选择一个服务端框架，常见的就是Express、Koa，默认是Node，即Nuxt默认服务器，我这里选了Express。")]),t._v(" "),n("ul",[n("li",[t._v("选择默认的Nuxt服务器，不会生成server文件夹，所有服务端渲染的操作都是Nuxt帮你完成，无需关心服务端的细节，开发体验更接近Vue项目，缺点是无法做一些服务端定制化的操作。")]),t._v(" "),n("li",[t._v("选择其他的服务端框架，比如Express，会生成server文件夹，帮你搭建一个基本的Node服务端环境，可以在里面做一些node端的操作。比如我公司业务需要（解析protobuf）使用了Express，对真正的服务端api做一层转发，在node端解析protobuf后，返回json数据给客户端。")])]),t._v(" "),n("p",[t._v("还有Choose Nuxt.js modules（选择nuxt.js的模块），可以选axios和PWA,如果选了axios，则会帮你在nuxt实例下注册$axios，让你可以在.vue文件中直接this.$axios发起请求。")]),t._v(" "),n("h3",{attrs:{id:"开启eslint检查"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开启eslint检查"}},[t._v("#")]),t._v(" 开启eslint检查")]),t._v(" "),n("p",[t._v("在nuxt.config.js的build属性下添加")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("build: {\n  extend(config, ctx) {\n    // Run ESLint on save\n    if(ctx.isDev && ctx.isClient) {\n      config.module.reules.push({\n        enforce: 'pre',\n        test: /\\.(js|vue)$/,\n        loader: 'eslint-loader',\n        exclude: /(node_module)/\n      })\n    }\n  }\n}\n")])])]),n("p",[t._v("这样开发时保存文件就可以检查语法了。nuxt默认使用的规则是"),n("a",{attrs:{href:"https://github.com/nuxt/eslint-config",target:"_blank",rel:"noopener noreferrer"}},[t._v("@nuxtjs"),n("OutboundLink")],1),t._v("--底层是"),n("a",{attrs:{href:"https://github.com/standard/eslint-config-standard",target:"_blank",rel:"noopener noreferrer"}},[t._v("eslint-config-standard"),n("OutboundLink")],1),t._v(",默认配置在/。eslintrc.js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("module.exports = {\n  root: true,\n  env: {\n    browser: true,\n    node: true\n  },\n  parserOptions: {\n    parser: 'babel-eslint'\n  },\n  extends: [\n    '@nuxtjs', // 改规则对应这个依赖：@nuxtjs/eslint-config\n    'plugin:nuxt/recommended'\n  ],\n  // add you custom rules here\n  rules: {\n    'nuxt/no-cjs-in-config': 'off'\n  }\n}\n")])])]),n("p",[t._v("如果不习惯用standard规则的团队可以将@nuxtjs改成其他的")]),t._v(" "),n("h3",{attrs:{id:"使用dotenv和-nuxtjs-dotenv统一管理环境变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用dotenv和-nuxtjs-dotenv统一管理环境变量"}},[t._v("#")]),t._v(" 使用dotenv和@nuxtjs/dotenv统一管理环境变量")]),t._v(" "),n("p",[t._v("在node端，我们喜欢使用dotenv来管理项目中的环境变量，把所有环境变量都放在根目录下的.env中")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("安装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm i dotenv\n")])])])]),t._v(" "),n("li",[n("p",[t._v("使用")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在根目录新建一个.env文件，并写上需要管理的环境变量，比如服务端渎职APIHOST")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("APIHOST = http://your_server.com/api\n")])])])]),t._v(" "),n("li",[n("p",[t._v("在/server/index.js中使用(该文件是选Express服务端框架自动生成的)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("require('dotenv').config()\n\n// 通过process.env即可使用\nconsole.log(process.env.APIHOST) // http://your_server.com/api\n")])])])])])])]),t._v(" "),n("p",[t._v("此时我们只是让服务端可以使用.env的文件而已，Nuxt客户端并不能使用，按"),n("a",{attrs:{href:"https://nuxtjs.org/docs/configuration-glossary/configuration-env/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nuxt.js文档"),n("OutboundLink")],1),t._v("所说,可以将客户端的环境变量放置在nuxt.config.js中：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("module.exports = {\n  env: {\n    baseUrl: process.env.BASE_URL || 'http://localhost:3000'\n  }\n}\n")])])]),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),n("p",[t._v("但如果node端和客户端需要使用同一个环境变量时(后面讲到API鉴权时会使用同一个SECRET变量),就需要同时在nuxt.config.js和.env维护这个字段，比较麻烦，我们更希望环境变量只需要在一个地方维护，所以为了解决这个问题，我找到了@nuxtjs/dotenv这个依赖，它使得nuxt客户端也可以直接使用.env，达到我们的预期")])]),t._v(" "),n("p",[t._v("客户端也是通过process.env.XXX来使用，不在举例了。")]),t._v(" "),n("p",[t._v("另外，"),n("a",{attrs:{href:"https://www.npmjs.com/package/@nuxtjs/dotenv",target:"_blank",rel:"noopener noreferrer"}},[t._v("@nuxtjs/dotenv"),n("OutboundLink")],1),t._v("允许打包时指定其他的env文件。比如，开始时我们使用的是.env，但是我们打包的线上版本想用其他环境变量，此时我们可以指定build时用另一份文件如/.env.prod，只需要在nuxt.config.js指定")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("module.exports = {\n  modules: [\n    ['@nuxtjs/dotenv', { filename: '.env.prod' }] // 指定打包时候使用的dotenv\n  ]\n}\n")])])]),n("h3",{attrs:{id:"nuxt-toast模块"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nuxt-toast模块"}},[t._v("#")]),t._v(" @nuxt/toast模块")]),t._v(" "),n("p",[t._v("toast可以说是很常用的功能，一般的UI框架都会有这个功能。但如果你的站点没有使用UI框架，而alert又太丑，不放引入该模块")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm install @nuxtjs/toast\n")])])]),n("p",[t._v("然后在nuxt.config.js引入")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("module.exports = {\n  modules: [\n    '@nuxtjs/toast',\n    ['@nuxtjs/dotenv', { filename: '.env.prod' }] // 指定打包时使用的dotenv\n  ],\n  // toast模块的配置\n  toast: {\n    position: 'top-center',\n    duration: 2000\n  }\n}\n")])])]),n("p",[t._v("这样，nuxt就会在全局注册$toast方法供你使用，非常方便：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("this.$toast.error('服务器开小差啦~~')\nthis.$toast.error('请求成功~~')\n")])])]),n("p",[n("a",{attrs:{href:"https://github.com/nuxt-community/community-modules/blob/master/packages/toast/index.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("github @nuxt/js"),n("OutboundLink")],1)]),t._v(" "),n("h3",{attrs:{id:"api鉴权"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api鉴权"}},[t._v("#")]),t._v(" API鉴权")]),t._v(" "),n("p",[t._v("对于某些敏感的服务，我们可能需要对API进行鉴权，防止被人轻易盗用我们node端的API，因此我们需要做一个API的鉴权机制.常见的方案有jwt，可以参考一下阮老师的介绍：《JSON Web Token 入门教程》(http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html),如果场景比较简单，可以自行设计一下，这里提供一个思路")]),t._v(" "),n("ol",[n("li",[t._v("客户端和node端在环境变量中声明一个秘钥:SECRET=xxx,注意这个是保密的")]),t._v(" "),n("li",[t._v("客户端发起请求时，将当前时间戳(timestamp)和SECRET通过某种算法，生成一个signature,请求时带上timestamp和signature;")]),t._v(" "),n("li",[t._v("node接收到请求，获得timestamp和signature，将timestamp和秘钥用同样的算法在生成一次签名_signature")]),t._v(" "),n("li",[t._v("对于客户端请求的signature和node用同样的算法生成的_signature，如果一直就表示通过，否则鉴权失败。")])]),t._v(" "),n("p",[t._v("具体步骤：")]),t._v(" "),n("p",[t._v("客户端对axios进行一层封装")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import axios from 'axios';\nimport sha256 from 'crypto-js/sha256';\nimport Base64 from 'crypto-js/enc-base64';\n// 加密算法，需安装crypto-js\nfunction crypto(str) {\n  const _sign = sha256(str);\n  return encodeURIComponent(Base64.stringify(_sign));\n}\n\nconst SECRET = process.env.SECRET;\n\nconst options = {\n  headers: { 'X-Requested-With': 'XMLHttpRequest' },\n  timeout: 30000,\n  baseURL: '/api'\n}\n\n// The server-side needs a full url to works\nif(process.server) {\n  options.baseURL = `http://${process.env.HOST || 'localhost'}:${process.env.PORT || 3000}/api`;\n  options.widthCredentials = true\n}\n\nconst instance = axios.create(options);\n// 对axios的每一个请求都做一个处理，携带上签名和timestamp\ninstance.interceptors.request.use(config => {\n  const timestamp = new Date().getTime();\n  const param = `timestamp=${timestamp}&secret=${SECRET}`;\n  const sign = crypto(param);\n  config.params = Object.assign({}, config.params, { timestamp, sign })\n})\n\nexport default instance\n")])])]),n("p",[t._v("接着，在server端写一个鉴权的中间件，/server/middleware/verify.js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const sha256 = require('crypto-js/sha256');\nconst Base64 = require('crypto-js/enc-base64');\n\nfunction crypto(str) {\n  const _sign = sha256(str);\n  return encodeURIComponent(Base64.startsWith(_sign))\n}\n\n// 使用和客户端相同的秘钥\nconst SECRET = process.env.SECRET;\n\nfunction verifyMiddleware(req, res, next) {\n  const { sign, timestamp } = req.query;\n  // 加密算法与请求时一致\n  const _sign = crypto(`timestamp=${timestamp}&secret=${SECRET}`);\n\n  if(_sign === sign) {\n    next();\n  } else {\n    res.status(401).send({\n      message: 'invalid token'\n    })\n  }\n}\nmodule.exports = { verifyMiddleware }\n")])])]),n("p",[t._v("最后，在需要鉴权的路由中引用这个中间件，/server/index.js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const { Router } = require('express')\nconst { verifyMiddleware } = require('../middleware/verify.js')\nconst router = Router()\n\n// 在需要鉴权的路由加上\nrouter.get('/test', verifyMiddleware, function (req, res, next) {\n    res.json({name: 'test'})\n})\n")])])]),n("h3",{attrs:{id:"静态文件处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态文件处理"}},[t._v("#")]),t._v(" 静态文件处理")]),t._v(" "),n("p",[t._v("根目录下有个/static文件夹，我们希望这里面的文件可以直接通过url访问，需要在/server/index.js中加入一句")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const express = require('express');\nconst app = express();\n\napp.use('/status', express.static('static'))\n")])])]),n("h2",{attrs:{id:"nuxt开发相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nuxt开发相关"}},[t._v("#")]),t._v(" Nuxt开发相关")]),t._v(" "),n("h3",{attrs:{id:"声明周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#声明周期"}},[t._v("#")]),t._v(" 声明周期")]),t._v(" "),n("p",[t._v("Nuxt扩展了Vue的生命周期，大概如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n  middleware() {}, // 服务端\n  validate() {}, // 服务端\n  asyncData() {}, // 服务端\n  fetch() {}, // store数据加载\n  beforeCreate() {}, // 服务端和客户端都会执行\n  created() {}, // 服务端和客户端都会执行\n  beforeMount() {},\n  mounted() {} // 客户端 \n}\n")])])]),n("h3",{attrs:{id:"asyncdata"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncdata"}},[t._v("#")]),t._v(" asyncData")]),t._v(" "),n("p",[t._v("该方法是Nuxt最大的一个卖点，服务端渲染的能力就在这里，首次渲染必须使用该方法。asyncData会传进一个context参数，通过该参数可以获取一些信息如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n  asyncData(ctx) {\n    ctx.app // 根实例\n    ctx.route // 路由实例\n    ctx.params // 路由参数\n    ctx.query // 路由问号后面的参数\n    ctx.error // 错误处理方法\n  }\n}\n")])])]),n("h3",{attrs:{id:"渲染出错和ajax请求出错的处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#渲染出错和ajax请求出错的处理"}},[t._v("#")]),t._v(" 渲染出错和ajax请求出错的处理")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("asyncData渲染出错")]),t._v(" "),n("p",[t._v("使用asyncData钩子时可能会由于服务器错误或api错误导致无法渲染，此时页面还为渲染出来，需要针对这种情况做一些处理，当遇到asyncData错误时，跳转到错误页面，nuxt提供了context.error方法用于错误处理，在asyncData中调用该方法即可跳转到错误页面")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n  asyncData(ctx) {\n    // 尽量使用try catch的写法，将所有异常都捕捉到\n    try {\n      throw new Error()\n    } catch {\n      ctx.error({statusCode: 500, message: '服务器开了小差了~'})\n    }\n  }\n}\n")])])]),n("p",[t._v("这样，当出现异常时会跳转到"),n("a",{attrs:{href:"https://nuxtjs.org/docs/concepts/views/#%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2",target:"_blank",rel:"noopener noreferrer"}},[t._v("默认的错误页"),n("OutboundLink")],1),t._v(",错误页面可以通过/layout/error.vue自定义。")]),t._v(" "),n("p",[t._v("这里会遇到一个问题,context.error的参数必须是类似{ statusCode: 500, message: '服务器开小差了~' }, statusCode必须是http状态码，而我们服务端返回的错误往往有一些其他自定义的代码，如{ statusCode: 10005, resultInfo: '服务器内部错误' }，此时需要对返回的api错误进行转换一下")]),t._v(" "),n("p",[t._v("为了方便，我引入了/plugin/ctx-inject.js为context注册一个全局的错误处理方法：")]),t._v(" "),n("p",[t._v("context.$errorHandler(err)。注入方法可以参考:"),n("a",{attrs:{href:"https://nuxtjs.org/docs/directory-structure/plugins/#%E6%B3%A8%E5%85%A5-vue-%E5%AE%9E%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("注入$root和context"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("ctx-inject.js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//为context注册全局的错误处理事件\nexport default (ctx, inject) => {\n  ctx.$errorHandler = err => {\n    try {\n      const res = res.data;\n      if (res) {\n        // 由于nuxt的错误页面只能识别http状态码，因此statusCode统一传500，表示服务器异常\n        ctx.error({ statusCode: 500, message: res.resultInfo })\n      } else {\n        ctx.error({ statusCode: 500, message: '服务器开小差了' })\n      }\n    } catch {\n      ctx.error({ statusCode: 500, message: '服务器开小差了~' })\n    }\n  }\n}\n")])])]),n("p",[t._v("然后在nuxt.config.js使用该插件")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n  plugins: [\n    '~/plugins/ctx-inject.js'\n  ]\n}\n")])])]),n("p",[t._v("注入完毕，我们可以在asyncData使用了")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n  async asyncData (ctx) {\n      // 尽量使用try catch的写法，将所有异常都捕捉到\n      try {\n          throw new Error()\n      } catch(err) {\n          ctx.$errorHandler(err)\n      }\n  }\n}\n")])])])]),t._v(" "),n("li",[n("p",[t._v("ajax请求出错")]),t._v(" "),n("p",[t._v("对于ajax的异常，此时页面已经渲染，出现错误时不必跳转到错误页，可以通过this.$toast.error(res.message) toast出来就可")])])]),t._v(" "),n("h3",{attrs:{id:"loading方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#loading方法"}},[t._v("#")]),t._v(" loading方法")]),t._v(" "),n("p",[t._v("nuxt内置了页面顶部"),n("a",{attrs:{href:"https://nuxtjs.org/docs/configuration-glossary/configuration-loading/#loading-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE",target:"_blank",rel:"noopener noreferrer"}},[t._v("loading进度条的样式"),n("OutboundLink")],1),t._v(" 推荐使用，提供页面跳转体验。 打开： this.$nuxt.$loading.start() 完成： this.$nuxt.$loading.finish()")]),t._v(" "),n("h3",{attrs:{id:"打包部署"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打包部署"}},[t._v("#")]),t._v(" 打包部署")]),t._v(" "),n("p",[t._v("一般来说，部署前可以先在本地打包，本地跑一下确认无误后再上传到服务器部署。命令")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 打包\nnpm run build\n// 本地跑\nnpm start\n")])])]),n("p",[t._v("除node_modules，.git,.env，将其他的文件都上传到服务器，然后通过pm2进行管理,可以在项目根目录建一个pm2.json方便维护：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('{\n  "name": "nuxt-test",\n  "script": "./server/index.js",\n  "instances": 2,\n  "cwd": "."\n}\n')])])]),n("p",[t._v("然后配置生产环境的环境变量，一般是直接用.env.prod的配置：cp ./.env.prod ./.env。 首次部署或有新的依赖包，需要在服务器上npm install一次，然后就可以用pm2启动进程啦：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 项目根目录下运行\npm2 start ./pm2.json\n\n")])])]),n("p",[t._v("需要的话，可以设置开机自动启动pm2: pm2 save && pm2 startup。 需要注意的是，每次部署都得重启一下进程:pm2 reload nuxt-test。")]),t._v(" "),n("h2",{attrs:{id:"最后"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),n("p",[t._v("Nuxt.js引入了Node,同时nuxt.config.js替代了main.js的一些作用，目录结构和vue项目有稍有不同，增加了很多约定")]),t._v(" "),n("p",[t._v("demo源码： "),n("a",{attrs:{href:"https://github.com/fengxianqi/front_end-demos/tree/master/src/nuxt-test",target:"_blank",rel:"noopener noreferrer"}},[t._v("fengxianqi/front_end-demos/src/nuxt-test"),n("OutboundLink")],1),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/6844903906200256525#heading-18",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nuxt.js实战和配置"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);